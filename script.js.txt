// Initialize all page functionality when DOM is fully loaded
document.addEventListener('DOMContentLoaded', function() {
    console.log("DOM loaded. Initializing scripts..."); // Debug log
    initializeSidebarToggle(); // Using older version logic
    initializeSearchFunctionality(); // Using older version logic
    initializePageSpecificFeatures(); // Calls specific page inits
    initializeAssignmentFormListener(); // Using older version logic
    initializeResetModalListeners(); // Using older version logic
    initializeStudentModalListeners(); // Using older version logic for modals
    initializeDropdownListeners(); // Using older version logic
    initializeAddStudentFormListener(); // << OLDER fetch logic (KEEP)
    initializeEditStudentFormListener(); // << OLDER fetch logic (KEEP)
    initializeImportStudentsFormListener(); // Using older version logic
    initializeBulkStudentActions(); // << ADDED Corrected Bulk Delete logic (Uses fetchWithErrorHandling_Robust)
    initializeClassManagement(); // << OLDER fetch logic (KEEP)

    // Debug: Log counts after initialization (optional)
    // console.log("Edit student buttons found:", document.querySelectorAll('[onclick*="showEditStudentModal"]').length);
    // console.log("Delete student buttons found:", document.querySelectorAll('[onclick*="deleteStudent"]').length);
});

// --- Utility Functions (Using older versions primarily, adding newer fetch for bulk delete) ---
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => { clearTimeout(timeout); func(...args); };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// --- KEEP OLD fetchWithErrorHandling (Simpler version) ---
// Used by Add/Edit Student/Class, Grade updates, Assignment updates, etc. in the older functions
async function fetchWithErrorHandling(url, options = {}) {
    try {
        // Default to JSON content type if not FormData
        const headers = { ...options.headers };
        if (!(options.body instanceof FormData)) {
            headers['Content-Type'] = headers['Content-Type'] || 'application/json';
        }

        const response = await fetch(url, {
            ...options,
            headers: headers
        });
        if (!response.ok) {
            let errorMsg = `HTTP error! status: ${response.status}`;
            try { // Try to get more info from response body
                const errBody = await response.json();
                errorMsg = errBody.message || errorMsg;
            } catch(e) { /* Ignore if body isn't JSON */ }
            throw new Error(errorMsg);
        }
        // Check content type before parsing JSON - important for file uploads/downloads
        const contentType = response.headers.get("content-type");
         if (contentType && contentType.includes("application/json")) {
             return await response.json();
         } else {
             console.warn(`Response from ${url} was not JSON. Returning raw response.`);
             // For file downloads or simple text responses from older functions
             return response; // Return the raw response for non-JSON cases
         }

    } catch (error) {
        console.error(`Fetch error for ${url}:`, error);
        // Throw the error so the calling function's catch block handles it
        throw error;
    }
}
// --- END OLD fetchWithErrorHandling ---

// --- ADD NEW fetchWithErrorHandling (Robust version) for specific features ---
// Renamed to avoid conflict, used ONLY by Bulk Delete
async function fetchWithErrorHandling_Robust(url, options = {}) {
    const defaultHeaders = { 'Content-Type': 'application/json', 'Accept': 'application/json' };
    const mergedHeaders = { ...defaultHeaders, ...options.headers };
    if (options.body instanceof FormData) delete mergedHeaders['Content-Type'];
    try {
        const response = await fetch(url, { ...options, headers: mergedHeaders });
        const contentType = response.headers.get("content-type");
        let responseData;
        if (contentType && contentType.includes("application/json")) {
            responseData = await response.json();
        } else {
            const textResponse = await response.text();
            if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}. Response: ${textResponse}`);
            console.warn(`Unexpected non-JSON response from ${url}. CT: ${contentType}`);
            // Return consistent format even for non-JSON success
            return { success: true, data: textResponse };
        }
        if (!response.ok) {
            // If it IS JSON but not ok, extract error
            const errorMessage = responseData.message || `HTTP error! Status: ${response.status}`;
            throw new Error(errorMessage);
        }
        // Assume success if no error was thrown
        // Backend should ideally send {success: true/false, ...}
        return responseData;
    } catch (error) {
        console.error(`Robust Fetch error for ${url}:`, error);
        // Propagate error for specific handling in the caller (e.g., bulk delete)
        throw error;
    }
}
// --- END NEW fetchWithErrorHandling_Robust ---


// Older showToast
function showToast(message, type = 'success') {
    const toastContainer = document.getElementById('toast-container') || createToastContainer();
    const iconClass = type === 'success' ? 'fa-check-circle' : type === 'error' ? 'fa-exclamation-triangle' : 'fa-info-circle';
    const bgColor = type === 'success' ? 'bg-green-500' : type === 'error' ? 'bg-red-600' : 'bg-blue-500';
    const toast = document.createElement('div');
    toast.className = `p-3 rounded-lg shadow-md text-white text-sm ${bgColor} flex items-center transform transition-all duration-300 translate-x-full opacity-0 mb-2`;
    toast.innerHTML = `<i class="fas ${iconClass} mr-2"></i><span>${message}</span>`;
    toastContainer.prepend(toast);
    setTimeout(() => { toast.classList.remove('translate-x-full', 'opacity-0'); toast.classList.add('translate-x-0', 'opacity-100'); }, 10);
    setTimeout(() => {
        toast.classList.remove('translate-x-0', 'opacity-100'); toast.classList.add('opacity-0');
        toast.addEventListener('transitionend', () => { if(toast.parentNode) toast.remove(); }, { once: true });
    }, 4000);
}

// Older createToastContainer
function createToastContainer() {
    let container = document.getElementById('toast-container');
    if (!container) {
        container = document.createElement('div');
        container.id = 'toast-container';
        container.className = 'fixed top-4 right-4 z-[100] w-64 space-y-2';
        document.body.appendChild(container);
    }
    return container;
}


// Older setLoadingState (Adjusted slightly)
function setLoadingState(element, isLoading, originalContent = null) {
    if (!element) return;
    const spinnerIcon = '<i class="fas fa-spinner fa-spin mr-2"></i>';
    if (isLoading) {
        if (!element.dataset.originalContent) element.dataset.originalContent = element.innerHTML;
        element.disabled = true;
        element.innerHTML = `${spinnerIcon}Working...`;
    } else {
        element.disabled = false;
        if (element.dataset.originalContent) {
            element.innerHTML = element.dataset.originalContent;
            delete element.dataset.originalContent;
        } else if (originalContent) {
             element.innerHTML = originalContent;
        } else {
            element.textContent = 'Submit'; // Fallback
        }
    }
}

// Older getStatusInfoFromGrade
function getStatusInfoFromGrade(grade) {
    if (grade === null || grade === undefined || isNaN(grade)) { return { text: 'N/A', classes: 'bg-gray-100 text-gray-800' }; }
    grade = parseInt(grade);
    if (grade >= 90) return { text: 'Excellent', classes: 'bg-green-100 text-green-800' };
    if (grade >= 70) return { text: 'Good', classes: 'bg-blue-100 text-blue-800' };
    if (grade >= 60) return { text: 'Needs Help', classes: 'bg-yellow-100 text-yellow-800' };
    return { text: 'At Risk', classes: 'bg-red-100 text-red-800' };
}

function showNotImplementedToast(feature = 'This feature') { showToast(`${feature} is not implemented.`, 'info'); } // Corrected message

// --- Sidebar (Using older version) ---
function initializeSidebarToggle() {
    const sidebar = document.getElementById('sidebar'), toggleBtn = document.getElementById('sidebarToggle'), toggleIcon = document.getElementById('toggleIcon'), overlay = document.getElementById('overlay');
    if (!sidebar || !toggleBtn || !toggleIcon || !overlay) { console.warn("Sidebar elements missing."); return; }
    const isCollapsed = localStorage.getItem('sidebarCollapsed') === 'true';
    if (isCollapsed) { sidebar.classList.add('collapsed'); toggleIcon.className = 'fas fa-bars'; } else { sidebar.classList.remove('collapsed'); toggleIcon.className = 'fas fa-times'; if (window.innerWidth <= 768) { overlay.classList.add('active'); document.body.style.overflow = 'hidden'; } }
    toggleBtn.addEventListener('click', () => { const willBeCollapsed = !sidebar.classList.contains('collapsed'); sidebar.classList.toggle('collapsed'); toggleIcon.className = willBeCollapsed ? 'fas fa-bars' : 'fas fa-times'; if (window.innerWidth <= 768) { overlay.classList.toggle('active', !willBeCollapsed); document.body.style.overflow = willBeCollapsed ? '' : 'hidden'; } localStorage.setItem('sidebarCollapsed', willBeCollapsed); });
    overlay.addEventListener('click', () => { sidebar.classList.add('collapsed'); toggleIcon.className = 'fas fa-bars'; overlay.classList.remove('active'); document.body.style.overflow = ''; localStorage.setItem('sidebarCollapsed', true); });
    document.querySelectorAll('.nav-item').forEach(item => { item.addEventListener('click', () => { if (window.innerWidth <= 768 && !sidebar.classList.contains('collapsed')) { sidebar.classList.add('collapsed'); toggleIcon.className = 'fas fa-bars'; overlay.classList.remove('active'); document.body.style.overflow = ''; localStorage.setItem('sidebarCollapsed', true); } }); });
    window.addEventListener('resize', () => { if (window.innerWidth > 768) { overlay.classList.remove('active'); document.body.style.overflow = ''; } else if (!sidebar.classList.contains('collapsed')) { overlay.classList.add('active'); document.body.style.overflow = 'hidden'; } });
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && !sidebar.classList.contains('collapsed')) { sidebar.classList.add('collapsed'); toggleIcon.className = 'fas fa-bars'; overlay.classList.remove('active'); document.body.style.overflow = ''; localStorage.setItem('sidebarCollapsed', true); } });
}

// --- Search (Using older version) ---
function initializeSearchFunctionality() {
    const searchInput = document.getElementById('studentSearch'); const resultsContainer = document.getElementById('searchResults'); if (!searchInput || !resultsContainer) return;
    searchInput.addEventListener('input', debounce(async (e) => {
        const query = e.target.value.trim(); resultsContainer.innerHTML = '';
        if (query.length < 2) { resultsContainer.classList.add('hidden'); return; }
        resultsContainer.innerHTML = '<div class="p-4 text-center text-gray-500 text-sm">Searching...</div>'; resultsContainer.classList.remove('hidden');
        try { const response = await fetch(`/search?q=${encodeURIComponent(query)}`); if (!response.ok) throw new Error(`HTTP error ${response.status}`); const students = await response.json(); displaySearchResults(students, query, resultsContainer); }
        catch (error) { console.error('Search failed:', error); showSearchError(resultsContainer, 'Search failed.'); }
    }, 300));
    document.addEventListener('click', (e) => { if (!e.target.closest('#studentSearch') && !e.target.closest('#searchResults')) { resultsContainer.classList.add('hidden'); } });
    searchInput.addEventListener('keydown', (e) => { if (e.key === 'Escape') { resultsContainer.classList.add('hidden'); searchInput.blur(); } });
}
function displaySearchResults(students, query, container) { if (students && students.length > 0) { container.innerHTML = students.map(s => `<a href="/student/${s.id}" class="block p-3 border-b hover:bg-gray-50"><div class="flex items-center justify-between"><div><p class="font-semibold text-gray-800 text-sm">${s.name}</p><p class="text-xs text-gray-600">${s.email}</p><p class="text-xs text-gray-500">Class: ${s.className||'N/A'} • Grade: ${s.overallGrade}%</p></div><i class="fas fa-chevron-right text-gray-400 text-xs"></i></div></a>`).join(''); } else { showNoResults(container, query); } container.classList.remove('hidden'); }
function showNoResults(container, query) { container.innerHTML = `<div class="p-4 text-center text-gray-500 text-sm"><i class="fas fa-search mr-2"></i>No results for "${query}"</div>`; container.classList.remove('hidden');}
function showSearchError(container, message) { container.innerHTML = `<div class="p-4 text-center text-red-600 text-sm"><i class="fas fa-exclamation-triangle mr-2"></i>${message}</div>`; container.classList.remove('hidden');}

// --- Grade/Score Update Functions (Using older fetch logic) ---
async function updateGrade(studentId, newGrade, event) {
    const inputElement = event ? event.target : null; let gradeNum;
    if (newGrade === null || String(newGrade).trim() === '') { showToast('Grade cannot be empty.', 'error'); if(inputElement) inputElement.focus(); return; }
    gradeNum = parseInt(newGrade); if (isNaN(gradeNum) || gradeNum < 0 || gradeNum > 100) { showToast('Grade must be 0-100.', 'error'); if(inputElement) inputElement.focus(); return; }
    if (inputElement) { inputElement.classList.add('border-yellow-500'); inputElement.disabled = true; }
    try {
        // Use OLD fetch
        const result = await fetchWithErrorHandling('/update_grade', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ student_id: studentId, new_grade: gradeNum }) });
        if (result.success) {
            showToast('Grade updated!', 'success');
            if (inputElement) {
                inputElement.classList.remove('border-yellow-500'); inputElement.classList.add('border-green-500','bg-green-50/50');
                setTimeout(() => { inputElement.classList.remove('border-green-500','bg-green-50/50'); updateStatusBadge(studentId, gradeNum); }, 1000);
            }
            if (window.location.pathname.startsWith('/class/')) { updateClassSummaryStats(); } // Call summary update
        } else { throw new Error(result.message || 'Update failed.'); }
    } catch (error) { console.error('Error updating grade:', error); showToast(`Error: ${error.message}`, 'error'); if(inputElement){ inputElement.classList.remove('border-yellow-500'); inputElement.classList.add('border-red-500'); } }
    finally { if (inputElement) inputElement.disabled = false; }
}
async function updateAssignmentGrade(assignmentId, studentId, score, event, totalPoints) {
    const inputElement = event ? event.target : null; let scoreToSave = null;
    if (score !== null && String(score).trim() !== '') {
        const scoreNum = parseInt(score); if (isNaN(scoreNum) || scoreNum < 0 || scoreNum > totalPoints) { showToast(`Score must be 0-${totalPoints} or empty.`, 'error'); if(inputElement) inputElement.focus(); return; }
        scoreToSave = scoreNum;
    }
    if (inputElement) { inputElement.classList.remove('border-red-500'); inputElement.classList.add('border-yellow-500'); inputElement.disabled = true; }
    try {
        // Use OLD fetch
        const result = await fetchWithErrorHandling('/update_assignment_grade', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ assignment_id: assignmentId, student_id: studentId, grade: scoreToSave }) });
        if (result.success) {
            showToast('Score updated!', 'success');
            if (inputElement) {
                inputElement.classList.remove('border-yellow-500'); inputElement.classList.add('border-green-500','bg-green-50/50');
                setTimeout(() => { inputElement.classList.remove('border-green-500','bg-green-50/50'); updateAssessmentRow(inputElement.closest('tr'), scoreToSave, totalPoints); }, 1000);
            }
        } else { throw new Error(result.message || 'Update failed.'); }
    } catch (error) { console.error('Error updating score:', error); showToast(`Error: ${error.message}`, 'error'); if(inputElement){ inputElement.classList.remove('border-yellow-500'); inputElement.classList.add('border-red-500'); } }
    finally { if (inputElement) inputElement.disabled = false; }
}
function updateStatusBadge(studentId, grade) {
     const row = document.querySelector(`tr[data-student-id="${studentId}"]`); if (!row) return;
     const statusCell = row.querySelector('.status-cell'); if (!statusCell) return;
     const statusInfo = getStatusInfoFromGrade(grade);
     statusCell.innerHTML = `<span class="px-2.5 py-0.5 inline-flex text-xs font-semibold rounded-full ${statusInfo.classes} status-badge">${statusInfo.text}</span>`;
     if (row.dataset.status !== undefined) row.dataset.status = statusInfo.text;
}
function updateAssessmentRow(tableRow, score, totalPoints) {
     if (!tableRow) return;
     const percentageCell = tableRow.querySelector('.percentage-cell'); const statusCell = tableRow.querySelector('.status-cell');
     let statusInfo = getStatusInfoFromGrade(null); let percentageHtml = '<span class="text-gray-400 text-sm">-</span>';
     const maxPoints = (typeof totalPoints === 'number' && totalPoints > 0) ? totalPoints : null;
     if (score !== null && maxPoints) {
         const percentage = Math.round((score / maxPoints) * 100); statusInfo = getStatusInfoFromGrade(percentage);
         const color = percentage >= 90 ? 'green' : percentage >= 70 ? 'blue' : percentage >= 60 ? 'yellow' : 'red';
         percentageHtml = `<span class="font-medium text-sm text-${color}-600">${percentage}%</span>`;
     }
     if (percentageCell) percentageCell.innerHTML = percentageHtml;
     if (statusCell) statusCell.innerHTML = (score !== null) ? `<span class="px-2.5 py-0.5 inline-flex text-xs font-semibold rounded-full status-badge ${statusInfo.classes}">${statusInfo.text}</span>` : '<span class="text-xs text-gray-400">Not Graded</span>';
}

// --- ADDED BACK updateClassSummaryStats ---
function updateClassSummaryStats() {
    console.log("Updating class summary stats...");
    const averageGradeDisplay = document.getElementById('classAverageGradeDisplay'); // Needs ID in class_view.html
    const studentsAtRiskDisplay = document.getElementById('studentsAtRiskCountDisplay'); // Needs ID in class_view.html
    const tableBody = document.getElementById('classStudentTableBody'); // Needs ID="classStudentTableBody" in class_view.html table body
    if (!tableBody) { console.warn("Class student table body not found for summary stats."); return; }
    const gradeInputs = tableBody.querySelectorAll('.grade-input');

    if (!averageGradeDisplay || !studentsAtRiskDisplay) { console.warn("Summary display elements not found."); return; }
    if (gradeInputs.length === 0) { averageGradeDisplay.textContent = 'N/A'; studentsAtRiskDisplay.textContent = '0'; return; }

    let totalGrade = 0, validCount = 0, atRiskCount = 0;
    gradeInputs.forEach(input => {
        const gradeVal = input.value;
        if (gradeVal !== null && gradeVal !== '' && !isNaN(gradeVal)) {
            const gradeNum = parseInt(gradeVal, 10);
            if (gradeNum >= 0 && gradeNum <= 100) { totalGrade += gradeNum; validCount++; if (gradeNum < 60) atRiskCount++; }
        }
    });
    const avg = validCount > 0 ? Math.round(totalGrade / validCount) : 'N/A';
    averageGradeDisplay.textContent = avg === 'N/A' ? 'N/A' : `${avg}%`;
    studentsAtRiskDisplay.textContent = atRiskCount;
    console.log(`Class Stats updated: Avg=${avg}, AtRisk=${atRiskCount}`);
}
// --- END ADDED BACK ---


// --- Page-Specific Initializers ---
function initializePageSpecificFeatures() {
    document.querySelectorAll('.grade-input, .score-input').forEach(input => {
        input.addEventListener('focus', function() { this.select(); this.classList.remove('border-green-500', 'border-red-500', 'border-yellow-500', 'bg-green-50/50'); });
        input.addEventListener('keydown', function(e) { if (e.key === 'Enter') { e.preventDefault(); this.blur(); } });
    });
    const currentPath = window.location.pathname;
    if (document.getElementById('gradeDistributionChart')) console.log("Init Dashboard...");
    else if (currentPath.startsWith('/class/')) initializeClassPage(); // << Calls updateClassSummaryStats
    else if (document.getElementById('searchAssignments')) initializeAssignmentsPageFilters();
    else if (document.getElementById('searchInput') && currentPath.includes('/students')) initializeStudentPageFilters(); // << Calls filterStudentsGlobally which calls updateBulkActionsVisibility
    else if (document.getElementById('gradebookFilterForm')) initializeGradebookPage();
    // initializeClassManagement(); // Called globally now
}

// --- Page-Specific Filter/Setup Functions ---

// Students Page Filters (students.html) - Includes call to updateBulkActionsVisibility
function initializeStudentPageFilters() {
    console.log("Initializing student page filters...");
    const searchInput = document.getElementById('searchInput');
    const statusFilter = document.getElementById('statusFilter');
    const gradeFilter = document.getElementById('gradeFilter');
    const sectionFilter = document.getElementById('sectionFilter');
    const campusFilter = document.getElementById('campusFilter');
    const studentTableBody = document.getElementById('studentTableBody');
    if (!studentTableBody) { console.warn("Student table body not found."); return; }
    if (!searchInput || !statusFilter || !gradeFilter || !sectionFilter || !campusFilter) { console.warn("Student filter elements not all found."); }
    const studentRows = Array.from(studentTableBody.querySelectorAll('.student-row'));

    // Make filter function global so bulk actions update can call it if needed, and also call bulk update internally
    window.filterStudentsGlobally = function filterStudents() {
        console.log("Filtering students...");
        const searchTerm = searchInput ? searchInput.value.toLowerCase().trim() : '';
        const statusValue = statusFilter ? statusFilter.value : 'all';
        const gradeValue = gradeFilter ? gradeFilter.value : 'all';
        const sectionValue = sectionFilter ? sectionFilter.value : 'all';
        const campusValue = campusFilter ? campusFilter.value : 'all';
        let visibleCount = 0;
        studentRows.forEach(row => {
            const name = row.dataset.name || ''; const email = row.dataset.email || ''; const uid = row.dataset.uid || ''; const status = row.dataset.status || 'N/A';
            const gradeName = row.dataset.gradeName || ''; const sectionName = row.dataset.sectionName || ''; const campusName = row.dataset.campusName || '';
            const matchesSearch = searchTerm === '' || name.includes(searchTerm) || email.includes(searchTerm) || uid.includes(searchTerm);
            const matchesStatus = statusValue === 'all' || status === statusValue;
            const matchesGrade = gradeValue === 'all' || gradeName === gradeValue.toLowerCase();
            const matchesSection = sectionValue === 'all' || sectionName === sectionValue.toLowerCase();
            const matchesCampus = campusValue === 'all' || campusName === campusValue.toLowerCase();
            const isVisible = matchesSearch && matchesStatus && matchesGrade && matchesSection && matchesCampus;
            row.style.display = isVisible ? '' : 'none'; if (isVisible) visibleCount++;
        });
        const noStudentsRow = studentTableBody.querySelector('tr:not(.student-row)');
        if (noStudentsRow) noStudentsRow.style.display = (visibleCount === 0) ? '' : 'none';
        // Call bulk action update *after* visibility is set
        if (typeof updateBulkActionsVisibility === 'function') updateBulkActionsVisibility(); // <<< UPDATE BULK BAR
        console.log(`Filtering done. Visible: ${visibleCount}`);
    }
    // Attach listeners
    if(searchInput) searchInput.addEventListener('input', debounce(window.filterStudentsGlobally, 300));
    if(statusFilter) statusFilter.addEventListener('change', window.filterStudentsGlobally);
    if(gradeFilter) gradeFilter.addEventListener('change', window.filterStudentsGlobally);
    if(sectionFilter) sectionFilter.addEventListener('change', window.filterStudentsGlobally);
    if(campusFilter) campusFilter.addEventListener('change', window.filterStudentsGlobally);
    // Initial filter on load
    window.filterStudentsGlobally();
}


// Assignments Page Filters (assignments.html)
function initializeAssignmentsPageFilters() {
    const searchInput = document.getElementById('searchAssignments');
    const classFilter = document.getElementById('classFilter');
    const typeFilter = document.getElementById('typeFilter');
    const assignmentsGrid = document.querySelector('.assignments-grid');
    if (!assignmentsGrid) return;
    const checkboxList = document.getElementById('assignmentClassList');
    if(checkboxList) refreshAssignmentClassCheckboxes(checkboxList); else console.warn("#assignmentClassList missing.");
    if (!searchInput && !classFilter && !typeFilter) console.warn("Assignment filter elements missing.");
    const assignmentCards = Array.from(assignmentsGrid.querySelectorAll('.assignment-card'));
    function filterAssignments() {
        const searchTerm = searchInput ? searchInput.value.toLowerCase().trim() : '';
        const classValue = classFilter ? classFilter.value : 'all';
        const typeValue = typeFilter ? typeFilter.value : 'all';
        let visibleCount = 0;
        assignmentCards.forEach(card => {
            const title = card.dataset.title?.toLowerCase() || ''; const classId = card.dataset.classId || ''; const type = card.dataset.type?.toLowerCase() || ''; const className = card.dataset.className?.toLowerCase() || '';
            const matchesSearch = searchTerm === '' || title.includes(searchTerm) || className.includes(searchTerm);
            const matchesClass = classValue === 'all' || classId === classValue;
            const matchesType = typeValue === 'all' || type === typeValue;
            const isVisible = matchesSearch && matchesClass && matchesType;
            card.style.display = isVisible ? '' : 'none'; if (isVisible) visibleCount++;
        });
        const emptyState = assignmentsGrid.querySelector('div:not(.assignment-card)');
        if (emptyState) emptyState.style.display = (visibleCount === 0) ? '' : 'none';
    }
    if (searchInput) searchInput.addEventListener('input', debounce(filterAssignments, 300));
    if (classFilter) classFilter.addEventListener('change', filterAssignments);
    if (typeFilter) typeFilter.addEventListener('change', filterAssignments);
    filterAssignments();
 }
function initializeClassPage() { console.log("Class view page init..."); updateClassSummaryStats(); } // Calls summary stat update
function initializeGradebookPage() {
    const form = document.getElementById('gradebookFilterForm');
    const assignmentSelect = document.getElementById('assignment_id');
    const classSelect = document.getElementById('class_id');
    const submitForm = () => { if (assignmentSelect && classSelect && assignmentSelect.value && classSelect.value) form.submit(); };
    if (form && assignmentSelect && classSelect) {
        assignmentSelect.addEventListener('change', submitForm);
        classSelect.addEventListener('change', submitForm);
    }
 }

// --- Modal Functions (Using older versions) ---
function closeModal(modalId = 'studentModal') {
    const modal = document.getElementById(modalId); if (!modal) return;
    modal.classList.add('opacity-0'); const dialog = modal.querySelector('.bg-white.rounded-xl') || modal.children[0]; if (dialog) dialog.classList.add('scale-95', 'opacity-0');
    setTimeout(() => {
        modal.classList.add('hidden'); const form = modal.querySelector('form'); if (form) { form.reset(); form.querySelectorAll('[id$="Error"], .form-error').forEach(el => { el.textContent = ''; el.classList.add('hidden'); }); }
        if(modalId === 'addAssignmentModal') deselectAllClasses();
        if(modalId === 'importStudentsModal') { const fn = document.getElementById('csvFileName'); if(fn){ fn.textContent='No file chosen'; fn.classList.add('text-gray-400'); fn.classList.remove('text-gray-700'); } const fi = document.getElementById('student_csv'); if(fi) fi.value=''; }
    }, 300);
}
function showModal(modalId) {
    const modal = document.getElementById(modalId); const dialog = modal ? (modal.querySelector('.bg-white.rounded-xl') || modal.children[0]) : null;
    if (!modal || !dialog) { console.error(`Modal elements missing for ID: ${modalId}`); showToast('Error opening modal.', 'error'); return; }
    const form = modal.querySelector('form'); if (form) form.reset(); // Reset form just before showing
    modal.classList.remove('hidden'); requestAnimationFrame(() => { modal.classList.remove('opacity-0'); dialog.classList.remove('scale-95', 'opacity-0'); });
}
function showAddAssignmentModal() {
    const dueDateInput = document.getElementById('assignmentDueDate');
    if (dueDateInput) { try { const t = new Date(); t.setDate(t.getDate() + 1); dueDateInput.value = t.toISOString().split('T')[0]; } catch(e) { console.error("Could not set date", e); } }
    deselectAllClasses(); showModal('addAssignmentModal');
}
function closeAddAssignmentModal() { closeModal('addAssignmentModal'); }
async function showAddStudentModal() {
    const select = document.getElementById('studentClass'); // ID in Add Modal
    if(select) await refreshSelectWithOptions(select, '/api/get_classes', 'Error loading classes');
    showModal('addStudentModal');
}
function closeAddStudentModal() { closeModal('addStudentModal'); }
async function refreshSelectWithOptions(selectElement, apiUrl, errorMessage = 'Error loading', loadingElementId = null) {
     // Uses OLD fetch
     if (!selectElement) { console.error("Target select element missing."); return; }
     const loadingSpinner = loadingElementId ? document.getElementById(loadingElementId) : null;
     const previouslySelectedValue = selectElement.value;
     selectElement.disabled = true; if (loadingSpinner) loadingSpinner.classList.remove('hidden');
     selectElement.innerHTML = '<option value="" disabled selected>Loading...</option>';
     try {
         const response = await fetch(apiUrl + '?nocache=' + new Date().getTime()); // <<< OLD FETCH
         if (!response.ok) throw new Error(`HTTP ${response.status}`);
         const optionsData = await response.json(); if (!Array.isArray(optionsData)) throw new Error('Invalid data');
         selectElement.innerHTML = '<option value="" disabled>-- Select --</option>'; // Reset prompt
          // Add "All" option specifically for filter dropdowns
          if (selectElement.id === 'classFilter' || selectElement.id === 'classFilterStudents' || selectElement.id === 'sectionFilter' || selectElement.id === 'campusFilter' || selectElement.id === 'gradeFilter') {
              const allOpt = document.createElement('option');
              allOpt.value = 'all';
              // Determine appropriate "All" text
              if (selectElement.id.includes('Class')) allOpt.textContent = 'All Classes';
              else if (selectElement.id.includes('Section')) allOpt.textContent = 'All Sections';
              else if (selectElement.id.includes('Campus')) allOpt.textContent = 'All Campuses';
              else if (selectElement.id.includes('Grade')) allOpt.textContent = 'All Grades';
              else allOpt.textContent = 'All'; // Fallback
              selectElement.appendChild(allOpt);
          } else {
               // For modals, ensure the prompt is selected if no previous value
               selectElement.value = "";
          }

         // Populate options
         optionsData.sort((a, b) => { // Sort based on whether it's class data or simple strings
             const textA = (a.name && a.section) ? `${a.name} - ${a.section}` : a;
             const textB = (b.name && b.section) ? `${b.name} - ${b.section}` : b;
             return textA.localeCompare(textB);
         }).forEach(item => {
             const option = document.createElement('option');
             if (typeof item === 'object' && item.id && item.name && item.section) { // Class object
                 option.value = item.id; option.textContent = `${item.name} - ${item.section} (${item.campus || 'N/A'})`;
             } else { // Simple string (like section or grade)
                 option.value = item; option.textContent = item;
             }
             selectElement.appendChild(option);
         });

         // Restore previous selection or default to "All" for filters
         if (previouslySelectedValue && selectElement.querySelector(`option[value="${previouslySelectedValue}"]`)) { selectElement.value = previouslySelectedValue; }
         else if (selectElement.id.includes('Filter')) { selectElement.value = "all"; } // Default filters to "All"

     } catch (error) { console.error(`Error refreshing ${selectElement.id}:`, error); showToast(errorMessage, 'error'); selectElement.innerHTML = `<option value="" disabled selected>Error</option>`;
     } finally { selectElement.disabled = false; if (loadingSpinner) loadingSpinner.classList.add('hidden'); }
}
function showImportStudentsModal() { showModal('importStudentsModal'); }
function closeImportStudentsModal() { closeModal('importStudentsModal'); }
async function showEditStudentModal(studentId) {
    const modal = document.getElementById('editStudentModal'); const form = document.getElementById('editStudentForm'); if (!modal || !form) { console.error("Edit modal elements missing"); return; }
    form.reset(); form.dataset.studentId = ''; document.getElementById('editStudentModalTitle').textContent = 'Loading...';
    document.getElementById('uidDuplicateError')?.classList.add('hidden'); document.getElementById('rollNumberDuplicateError')?.classList.add('hidden');
    // Reset sliders if they exist
    document.querySelectorAll('#editStudentModal .skill-slider').forEach(s => { s.value = 1; const v = document.getElementById(s.id.replace('Rating','Value')); if(v) v.textContent = '1'; });
    const classSelect = document.getElementById('editStudentClass'); if(classSelect) await refreshSelectWithOptions(classSelect, '/api/get_classes', 'Error loading classes');
    showModal('editStudentModal');
    try {
        const response = await fetch(`/get_student_details?student_id=${studentId}`); // <<< OLD FETCH
        if (!response.ok) throw new Error(`HTTP ${response.status}`); const student = await response.json(); if (student.error) throw new Error(student.error);
        form.dataset.studentId = student.id; document.getElementById('editStudentModalTitle').textContent = `Edit ${student.name}`;
        form.elements['name'].value = student.name || ''; form.elements['email'].value = student.email || ''; form.elements['classId'].value = student.classId || '';
        form.elements['uid'].value = student.uid || ''; form.elements['rollNumber'].value = student.rollNumber || ''; form.elements['parentPhone'].value = student.parentPhone || '';
        const campusSelect = form.elements['campus']; if(campusSelect) campusSelect.value = student.campus || ''; // Populate campus
        if (student.skills && typeof student.skills === 'object') { for (const skillName in student.skills) { const r = student.skills[skillName]||0; const sId = `skillRatingEdit-${skillName.replace(/[\s&]/g,'_')}`; const vId = `skillValueEdit-${skillName.replace(/[\s&]/g,'_')}`; const sl = document.getElementById(sId); const vs = document.getElementById(vId); if(sl) sl.value = r; if(vs) vs.textContent = r; } }
    } catch (error) { console.error('Error fetching student details:', error); showToast(`Error loading data: ${error.message}`, 'error'); closeEditStudentModal(); }
}
function closeEditStudentModal() { closeModal('editStudentModal'); }
async function showManageClassesModal() {
    const classesList = document.getElementById('classes-list'); if (!classesList) { console.error("Classes list element missing"); return; }
    classesList.innerHTML = '<p class="text-center text-gray-500">Loading...</p>'; showModal('manage-classes-modal');
    try {
        const response = await fetch('/api/get_classes'); // <<< OLD FETCH
        if (!response.ok) throw new Error(`HTTP ${response.status}`); const classes = await response.json();
        classesList.innerHTML = ''; // Clear loading
        if (classes && classes.length > 0) {
            classes.sort((a,b) => (a.name+a.section).localeCompare(b.name+b.section)).forEach(cls => {
                const div = document.createElement('div'); div.className = 'flex justify-between items-center p-2 border-b';
                div.innerHTML = `<span>${cls.name} - ${cls.section} (${cls.campus||'N/A'}, Students: ${cls.studentCount||0})</span><div><button onclick="showEditClassModal('${cls.id}')" class="bg-yellow-500 text-white px-2 py-1 rounded hover:bg-yellow-600 text-xs">Edit</button><button onclick="deleteClass('${cls.id}')" class="bg-red-500 text-white px-2 py-1 rounded hover:bg-red-600 ml-2 text-xs ${cls.studentCount > 0 ? 'opacity-50 cursor-not-allowed' : ''}" ${cls.studentCount > 0 ? 'disabled title="Cannot delete class with students"' : ''}>Delete</button></div>`;
                classesList.appendChild(div);
            });
        } else { classesList.innerHTML = '<p class="text-center text-gray-500">No classes found.</p>'; }
    } catch (error) { console.error('Error fetching classes:', error); classesList.innerHTML = '<p class="text-center text-red-600">Error loading classes.</p>'; showToast('Failed to load classes.', 'error'); }
}
function closeManageClassesModal() { closeModal('manage-classes-modal'); }
function showAddClassModal() {
    const form = document.getElementById('class-form'); const title = document.getElementById('class-form-title'); if(!form || !title) return;
    title.textContent = 'Add Class'; form.reset(); document.getElementById('class-id').value = ''; document.getElementById('class-form-error').classList.add('hidden');
    document.getElementById('class-color').value = ''; document.querySelectorAll('input[name="color_option"]').forEach(r=>r.checked=false);
    showModal('class-form-modal'); form.onsubmit = (e) => { e.preventDefault(); addClass(); };
}
async function showEditClassModal(classId) {
    const form = document.getElementById('class-form'); const title = document.getElementById('class-form-title'); const errorEl = document.getElementById('class-form-error'); if(!form || !title || !errorEl) return;
    title.textContent = 'Loading...'; form.reset(); errorEl.classList.add('hidden'); showModal('class-form-modal');
    try {
        const response = await fetch(`/api/get_class/${classId}`); // <<< OLD FETCH
        if (!response.ok) throw new Error(`HTTP ${response.status}`); const data = await response.json(); if (data.error) throw new Error(data.error);
        title.textContent = 'Edit Class'; document.getElementById('class-id').value = data.id; form.elements['name'].value = data.name||''; form.elements['section'].value = data.section||''; form.elements['campus'].value = data.campus||'';
        const colorVal = data.color||''; document.getElementById('class-color').value = colorVal; const radio = form.querySelector(`input[name="color_option"][value="${colorVal}"]`); if(radio) radio.checked = true;
        form.onsubmit = (e) => { e.preventDefault(); editClass(classId); };
    } catch (error) { console.error('Error fetching class:', error); errorEl.textContent = 'Error loading details.'; errorEl.classList.remove('hidden'); showToast('Failed to load details.', 'error'); setTimeout(closeClassFormModal, 1500); }
}
function closeClassFormModal() { closeModal('class-form-modal'); }
function showResetConfirmation() { showModal('resetModal'); }
function hideResetConfirmation() { closeModal('resetModal'); }

// --- Modal Listeners (Using older version logic) ---
function initializeStudentModalListeners() {
     const modals = [ { id: 'studentModal', closeFn: () => closeModal('studentModal') }, { id: 'addStudentModal', closeFn: closeAddStudentModal }, { id: 'editStudentModal', closeFn: closeEditStudentModal }, { id: 'addAssignmentModal', closeFn: closeAddAssignmentModal }, { id: 'importStudentsModal', closeFn: closeImportStudentsModal }, { id: 'manage-classes-modal', closeFn: closeManageClassesModal }, { id: 'class-form-modal', closeFn: closeClassFormModal }, { id: 'resetModal', closeFn: hideResetConfirmation } ];
     modals.forEach(mInfo => { const modal = document.getElementById(mInfo.id); if (modal) { modal.addEventListener('click', function(e) { if (e.target === this) mInfo.closeFn(); }); } });
     document.addEventListener('keydown', (e) => { if (e.key === 'Escape') { modals.forEach(mInfo => { const modal = document.getElementById(mInfo.id); if (modal && !modal.classList.contains('hidden')) mInfo.closeFn(); }); } });
}

// --- Form Listeners ---
function initializeAssignmentFormListener() { /* ... Same as OLDER version (uses OLD fetch) ... */ }
function initializeAddStudentFormListener() { /* ... Same as OLDER version (uses OLD fetch) ... */ }
function initializeEditStudentFormListener() { /* ... Same as OLDER version (uses OLD fetch) ... */ }
function initializeImportStudentsFormListener() { /* ... Same as OLDER version (uses OLD fetch for FormData) ... */ }
function initializeResetModalListeners() { /* ... Same as OLDER version (uses OLD fetch) ... */ }

// --- Class Management Functions (<< USING OLDER fetch logic) ---
function initializeClassManagement() {
    const manageBtn = document.getElementById('manageClassesButton'); if(manageBtn) manageBtn.addEventListener('click', showManageClassesModal);
    const addBtn = document.getElementById('add-class-btn'); if(addBtn) addBtn.addEventListener('click', showAddClassModal);
    // Color picker listener from older code
    document.querySelectorAll('input[name="color_option"]').forEach(radio => { radio.addEventListener('change', () => { const target = document.getElementById(radio.dataset.colorTarget); if(target) target.value = radio.value; }); });
}
async function addClass() {
    const form = document.getElementById('class-form'); const btn = form.querySelector('button[type="submit"]'); const err = document.getElementById('class-form-error'); const original = btn? btn.innerHTML : 'Save';
    if(btn) setLoadingState(btn, true, original); if(err) err.classList.add('hidden');
    const data = { name: form.elements['name'].value.trim(), section: form.elements['section'].value.trim(), campus: form.elements['campus'].value.trim(), color: form.elements['color'].value };
    if (!data.name || !data.section || !data.campus || !data.color) { if(err){ err.textContent = 'All fields required.'; err.classList.remove('hidden'); } showToast('All fields required.', 'error'); if(btn) setLoadingState(btn, false, original); return; }
    try {
        const result = await fetchWithErrorHandling('/add_class', { method: 'POST', body: JSON.stringify(data) }); // OLD FETCH
        if (result.success) { closeClassFormModal(); await showManageClassesModal(); showToast('Class added!', 'success'); await refreshAllClassSelects(); }
        else { throw new Error(result.message || 'Error adding.'); }
    } catch (error) { console.error('Add class error:', error); if(err){ err.textContent = error.message; err.classList.remove('hidden'); } showToast(error.message, 'error'); }
    finally { if(btn) setLoadingState(btn, false, original); }
}
async function editClass(classId) {
    const form = document.getElementById('class-form'); const btn = form.querySelector('button[type="submit"]'); const err = document.getElementById('class-form-error'); const original = btn? btn.innerHTML : 'Save';
    if(btn) setLoadingState(btn, true, original); if(err) err.classList.add('hidden');
    const data = { name: form.elements['name'].value.trim(), section: form.elements['section'].value.trim(), campus: form.elements['campus'].value.trim(), color: form.elements['color'].value };
    if (!data.name || !data.section || !data.campus || !data.color) { if(err){ err.textContent = 'All fields required.'; err.classList.remove('hidden'); } showToast('All fields required.', 'error'); if(btn) setLoadingState(btn, false, original); return; }
    try {
        const result = await fetchWithErrorHandling(`/edit_class/${classId}`, { method: 'POST', body: JSON.stringify(data) }); // OLD FETCH
        if (result.success) { closeClassFormModal(); await showManageClassesModal(); showToast('Class updated!', 'success'); await refreshAllClassSelects(); }
        else { throw new Error(result.message || 'Error updating.'); }
    } catch (error) { console.error('Edit class error:', error); if(err){ err.textContent = error.message; err.classList.remove('hidden'); } showToast(error.message, 'error'); }
    finally { if(btn) setLoadingState(btn, false, original); }
}
async function deleteClass(classId) {
    if (!confirm('Delete this class?')) return;
    const btn = document.querySelector(`button[onclick="deleteClass('${classId}')"]`); const original = btn? btn.innerHTML : 'Delete';
    if(btn) setLoadingState(btn, true, original);
    try {
        const result = await fetchWithErrorHandling(`/delete_class/${classId}`, { method: 'POST' }); // OLD FETCH
        if (result.success) { await showManageClassesModal(); showToast('Class deleted!', 'success'); await refreshAllClassSelects(); }
        else { throw new Error(result.message || 'Error deleting.'); }
    } catch (error) { console.error('Delete class error:', error); showToast(error.message, 'error'); }
    finally { if(btn) setLoadingState(btn, false, original); } // Button might be gone, check needed if robust
}


// --- Bulk Student Actions (<< ADDED Corrected logic from Newer Version, uses NEWER robust fetch) ---
function initializeBulkStudentActions() {
    const bulkActionContainer = document.getElementById('bulkActionContainer');
    const deleteSelectedButton = document.getElementById('deleteSelectedButton'); // <<< Use correct ID from students.html
    const selectAllCheckbox = document.getElementById('selectAllCheckbox'); // <<< Use correct ID from students.html
    const studentTableBody = document.getElementById('studentTableBody');
    const selectedCountText = document.getElementById('selectedCountText'); // <<< Use correct ID from students.html

    if (!bulkActionContainer || !deleteSelectedButton || !selectAllCheckbox || !studentTableBody || !selectedCountText) {
        console.warn("Bulk action elements not fully found (Container, Delete Btn, SelectAll CB, Table Body, or Count Text). Skipping bulk actions."); return; // Added Count Text check
    }
    const studentCheckboxes = studentTableBody.querySelectorAll('.student-checkbox');
    if (studentCheckboxes.length === 0) { console.log("No student checkboxes found."); bulkActionContainer.classList.add('hidden'); selectAllCheckbox.disabled = true; return; }
    console.log("Initializing Bulk Student Actions...");

    // Make update function global
    window.updateBulkActionsVisibility = () => {
        const visibleCheckboxes = Array.from(studentCheckboxes).filter(cb => cb.closest('tr').style.display !== 'none');
        const checkedCount = visibleCheckboxes.filter(cb => cb.checked).length;
        selectedCountText.textContent = `${checkedCount} student${checkedCount !== 1 ? 's' : ''} selected`;
        bulkActionContainer.classList.toggle('hidden', checkedCount === 0);
        deleteSelectedButton.disabled = (checkedCount === 0);
        selectAllCheckbox.checked = visibleCheckboxes.length > 0 && checkedCount === visibleCheckboxes.length;
        selectAllCheckbox.indeterminate = checkedCount > 0 && checkedCount < visibleCheckboxes.length;
         // console.log(`Bulk actions updated. Selected: ${checkedCount}`); // Optional Debug
    };

    selectAllCheckbox.addEventListener('change', () => {
        const visibleCheckboxes = Array.from(studentCheckboxes).filter(cb => cb.closest('tr').style.display !== 'none');
        visibleCheckboxes.forEach(cb => cb.checked = selectAllCheckbox.checked);
        updateBulkActionsVisibility();
    });
    studentCheckboxes.forEach(cb => { cb.addEventListener('change', updateBulkActionsVisibility); });

    deleteSelectedButton.addEventListener('click', async () => {
        const selectedIds = Array.from(studentCheckboxes).filter(cb => cb.checked && cb.closest('tr').style.display !== 'none').map(cb => cb.value);
        if (selectedIds.length === 0) { showToast('No visible students selected.', 'info'); return; }
        if (!confirm(`Delete ${selectedIds.length} student(s)?`)) return;
        const originalButtonHTML = deleteSelectedButton.innerHTML; setLoadingState(deleteSelectedButton, true, originalButtonHTML);
        try {
            // Use NEWER ROBUST fetch only for this bulk action
            const result = await fetchWithErrorHandling_Robust('/delete_students_bulk', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ student_ids: selectedIds }) });
            if (result.success !== false) { // Check specific false from robust fetch return
                showToast(result.message || `${result.deleted_count || selectedIds.length} students deleted!`, 'success');
                selectedIds.forEach(id => { document.querySelector(`tr[data-student-id="${id}"]`)?.remove(); });
                selectAllCheckbox.checked = false; updateBulkActionsVisibility(); // Hide bar, uncheck all
                // Consider *not* reloading automatically for better UX
            } else { throw new Error(result.message || 'Failed to delete students.'); }
        } catch (error) { console.error('Bulk delete error:', error); showToast(`Error: ${error.message}`, 'error');
        } finally { setLoadingState(deleteSelectedButton, false, originalButtonHTML); }
    });
    updateBulkActionsVisibility(); // Initial check
}
// --- END Bulk Student Actions ---


// --- Delete Functions ---
async function deleteStudent(studentId) {
    if (confirm(`Delete student? This cannot be undone.`)) { // Simplified confirm
        try {
            const result = await fetchWithErrorHandling(`/delete_student/${studentId}`, { method: 'POST' }); // OLD FETCH
            if (result.success) {
                showToast(result.message || 'Student deleted!', 'success');
                const row = document.querySelector(`tr[data-student-id="${studentId}"]`);
                if (row) row.remove(); else setTimeout(() => window.location.href = '/students', 1000);
                 // Close edit modal if open for this student
                 const editModal = document.getElementById('editStudentModal');
                 if (editModal && !editModal.classList.contains('hidden') && editModal.querySelector(`form[data-student-id="${studentId}"]`)) {
                     closeEditStudentModal();
                 }
            } else { throw new Error(result.message || 'Failed to delete.'); }
        } catch (error) { console.error('Error deleting student:', error); showToast(`Error: ${error.message}`, 'error'); }
    }
}
function deleteAssignment(assignmentId) {
     closeDropdowns();
     if (confirm('Delete assignment?')) {
         fetchWithErrorHandling('/delete_assignment', { method: 'POST', body: JSON.stringify({ assignment_id: assignmentId }) }) // OLD FETCH
         .then(result => {
             if (result.success) {
                 showToast('Assignment deleted.', 'success');
                 const card = document.querySelector(`button[onclick*="toggleDropdown('${assignmentId}')"]`)?.closest('.assignment-card');
                 if (card) { card.remove(); const grid = document.querySelector('.assignments-grid'); if (grid && !grid.querySelector('.assignment-card')) { const empty = grid.querySelector('div:not(.assignment-card)'); if(empty) empty.style.display = ''; } }
                 else { location.reload(); }
             } else { throw new Error(result.message || 'Failed to delete.'); }
         })
         .catch(error => { console.error('Error deleting assignment:', error); showToast(`Error: ${error.message}`, 'error'); });
     }
}

// --- Reset Data (Using older fetch logic) ---
async function resetAllData() {
    const btn = document.getElementById('confirmReset'); const original = btn? btn.innerHTML : 'Reset';
    if(btn) setLoadingState(btn, true, original);
    try {
        const result = await fetchWithErrorHandling('/reset_data', { method: 'POST' }); // OLD FETCH
        if (result.success) { showToast('Data reset!', 'success'); hideResetConfirmation(); setTimeout(() => window.location.href = '/', 1000); }
        else { throw new Error(result.message || 'Reset failed.'); }
    } catch (error) { console.error('Error resetting:', error); showToast(`Error: ${error.message}`, 'error'); }
    finally { if(btn) setLoadingState(btn, false, original); }
}

// --- Dropdown Functions (Using older version) ---
function toggleDropdown(targetId) { const d = document.getElementById(`dropdown-${targetId}`); if(d){ const h = d.classList.contains('hidden'); closeDropdowns(targetId); d.classList.toggle('hidden', !h); } }
function closeDropdowns(excludeId = null) { document.querySelectorAll('[id^="dropdown-"]').forEach(d => { if ((!excludeId || d.id !== `dropdown-${excludeId}`) && !d.classList.contains('hidden')) d.classList.add('hidden'); }); }
function initializeDropdownListeners() { document.addEventListener('click', (e) => { if (!e.target.closest('[onclick*="toggleDropdown"]') && !e.target.closest('[id^="dropdown-"]')) closeDropdowns(); }); }

// --- Helper Functions ---
async function refreshAssignmentClassCheckboxes(listElement) { /* ... Same logic as older version, but uses OLD fetch ... */ }
async function refreshAllClassSelects() { /* ... Same logic as older version, but uses OLD fetch ... */ }
function selectAllClasses() { /* ... Same as older version ... */ }
function deselectAllClasses() { /* ... Same as older version ... */ }

// Validation (<< USING OLDER version with OLDER fetch)
async function validateUniqueFields(studentId, uid, rollNumber) { /* ... Same as OLDER version (uses OLD fetch) ... */ }

// --- Global Exports (Ensure all onclick functions are present) ---
window.updateGrade = updateGrade;
window.updateAssignmentGrade = updateAssignmentGrade;
window.showToast = showToast;
// window.viewStudentDetails = viewStudentDetails; // If needed
window.closeModal = closeModal; // Use older close
window.showResetConfirmation = showResetConfirmation;
window.hideResetConfirmation = hideResetConfirmation;
window.resetAllData = resetAllData;
window.showAddStudentModal = showAddStudentModal;
window.closeAddStudentModal = closeAddStudentModal;
window.showEditStudentModal = showEditStudentModal;
window.closeEditStudentModal = closeEditStudentModal;
window.deleteStudent = deleteStudent;
window.toggleDropdown = toggleDropdown;
window.closeDropdowns = closeDropdowns;
window.editAssignment = (assignmentId) => { closeDropdowns(); showNotImplementedToast(`Edit Assignment ${assignmentId}`); };
window.deleteAssignment = deleteAssignment;
window.viewAssignmentGrades = (assignId, classId) => { closeDropdowns(); if (classId) window.location.href = `/gradebook?assignment_id=${assignId}&class_id=${classId}`; else showToast('Cannot determine class.', 'error'); };
window.showNotImplementedToast = showNotImplementedToast;
window.showImportStudentsModal = showImportStudentsModal;
window.closeImportStudentsModal = closeImportStudentsModal;
window.showManageClassesModal = showManageClassesModal;
window.closeManageClassesModal = closeManageClassesModal;
window.showAddClassModal = showAddClassModal;
window.showEditClassModal = showEditClassModal;
window.closeClassFormModal = closeClassFormModal;
window.addClass = addClass;
window.editClass = editClass;
window.deleteClass = deleteClass;
window.selectAllClasses = selectAllClasses;
window.deselectAllClasses = deselectAllClasses;
// window.validateUniqueFields = validateUniqueFields; // Keep internal

console.log("script.js loaded and all initializers called."); // Final debug log

