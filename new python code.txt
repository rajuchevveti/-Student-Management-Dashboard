from flask import Flask, render_template, request, jsonify, send_file, redirect, url_for, make_response, flash
import json
import os
import csv
from datetime import datetime, timedelta
import math
import io
try:
    from fpdf import FPDF
    from fpdf.enums import XPos, YPos
    FPDF_AVAILABLE = True
except ImportError:
    FPDF_AVAILABLE = False
    print("WARNING: fpdf2 not found. PDF generation will not work. Install with: pip install fpdf2")



app = Flask(__name__)
app.secret_key = os.urandom(24)

# --- Constants ---
DATA_FILE = 'data.json'
# UPDATED: Use specific grade names and add CAMPUSES constant
CLASSES = ['6th', '7th', '8th', '9th']
SECTIONS = ['Tata', 'Google', 'Infosys', 'Mahindra', 'Intel', 'Adobe', 'Verizon']
CAMPUSES = ['Yamuna Campus', 'Subhash Nagar Campus'] # Use only these campuses
DEFAULT_CAMPUS = 'Yamuna Campus' # Default for new/imported students

ASSIGNMENT_TYPES = ['Project', 'Quiz', 'Lab', 'Homework', 'Exam', 'Participation', 'Assessment', 'Test', 'Other']
ASSESSMENT_FILTER_TYPES = ['Quiz', 'Exam', 'Assessment', 'Test']
COMPANY_COLORS = {
    'Blue': 'bg-blue-500',
    'Green': 'bg-green-500',
    'Red': 'bg-red-500',
    'Purple': 'bg-purple-500',
    'Sky': 'bg-sky-500',
    'Amber': 'bg-amber-500',
    'Teal': 'bg-teal-500'
}

SECTION_COLOR_MAP = {
    'Tata': 'bg-red-500',
    'Google': 'bg-blue-500',
    'Infosys': 'bg-purple-500',
    'Mahindra': 'bg-green-500',
    'Intel': 'bg-sky-500',
    'Adobe': 'bg-red-600',
    'Verizon': 'bg-amber-500'
}
DEFAULT_DATE_SORT_KEY = "9999-12-31"

# --- NEW: Default Skills Constant ---
# Define a standard list of skills for new students
DEFAULT_SKILLS = {
    "Concept Understanding": 1,
    "Practical Implementation": 1,
    "Programming & Logic": 1,
    "Communication": 1
}

# Pass default skills and campuses to Jinja environment
@app.context_processor
def inject_global_constants():
    return dict(
        DEFAULT_SKILLS=DEFAULT_SKILLS.keys(),
        ALL_CAMPUSES=CAMPUSES
    )

# --- Data Handling Functions ---
def load_data():
    if os.path.exists(DATA_FILE):
        try:
            if os.path.getsize(DATA_FILE) == 0:
                return create_default_data()
            with open(DATA_FILE, 'r', encoding='utf-8') as f:
                data = json.load(f)
            return ensure_data_structure(data)
        except json.JSONDecodeError as e:
            return create_default_data()
        except Exception as e:
            return create_default_data()
    else:
        return create_default_data()

def ensure_data_structure(data):
    if not isinstance(data, dict):
        return create_default_data()
    
    required_keys = {'classes': [], 'students': [], 'alerts': [], 'assignments': [], 'grades': {}}
    needs_save = False
    
    for key, default in required_keys.items():
        current_value = data.get(key)
        if current_value is None:
            data[key] = default
            needs_save = True
        elif key == 'grades' and not isinstance(current_value, dict):
            data[key] = default
            needs_save = True
        elif key != 'grades' and not isinstance(current_value, list):
            data[key] = default
            needs_save = True
        elif isinstance(current_value, list):
            valid_items = [item for item in current_value if isinstance(item, dict)]
            if len(valid_items) != len(current_value):
                data[key] = valid_items
                needs_save = True

    # --- NEW: Skill Data Migration ---
    # Check if any student has the OLD skills list and migrate them
    for student in data.get('students', []):
        if isinstance(student, dict) and isinstance(student.get('skills'), list):
            print(f"Migrating skills for student: {student.get('id')}")
            student['skills'] = DEFAULT_SKILLS.copy()
            needs_save = True
        elif isinstance(student, dict) and not isinstance(student.get('skills'), dict):
            student['skills'] = DEFAULT_SKILLS.copy()
            needs_save = True
        
        # --- NEW: Campus Data Migration ---
        if isinstance(student, dict) and student.get('campus') == 'Main Campus':
            print(f"Migrating campus for student: {student.get('id')}")
            student['campus'] = DEFAULT_CAMPUS # Default to Yamuna Campus
            needs_save = True
        elif isinstance(student, dict) and not student.get('campus'):
            student['campus'] = DEFAULT_CAMPUS
            needs_save = True
            
    for cls in data.get('classes', []):
        if isinstance(cls, dict) and cls.get('campus') == 'Main Campus':
            print(f"Migrating campus for class: {cls.get('id')}")
            cls['campus'] = DEFAULT_CAMPUS
            needs_save = True
        elif isinstance(cls, dict) and not cls.get('campus'):
            cls['campus'] = DEFAULT_CAMPUS
            needs_save = True
    
    # --- NEW: Assignment Data Migration (Groups assignments) ---
    for assignment in data.get('assignments', []):
        if isinstance(assignment, dict) and 'classId' in assignment:
            # Old format found, migrate it
            print(f"Migrating assignment: {assignment.get('id')}")
            class_id = assignment.pop('classId') # Remove old key
            if class_id:
                assignment['classIds'] = [class_id] # Add new key as a list
            else:
                assignment['classIds'] = []
            needs_save = True
    # --- END Assignment Migration ---
            
    if needs_save:
        save_data(data)
    return data

def create_default_data():
    default_data = {"classes": [], "students": [], "alerts": [], "assignments": [], "grades": {}}
    class_id_c = 1
    student_id_c = 1
    for grade in CLASSES:
        for section in SECTIONS:
            c_id = f"c{class_id_c}"
            class_data = {
                "id": c_id,
                "name": f"Grade {grade}", # Use full name
                "section": section,
                "studentCount": 5,
                "color": SECTION_COLOR_MAP.get(section, 'bg-gray-500'),
                "grade": grade, # Store simple grade name
                "campus": DEFAULT_CAMPUS # Use default campus
            }
            default_data["classes"].append(class_data)
            for i in range(1, 6):
                s_id = f"s{student_id_c}"
                student = {
                    "id": s_id,
                    "classId": c_id,
                    "name": f"Student {student_id_c}",
                    "email": f"student{student_id_c}@school.edu",
                    "overallGrade": 70 + (student_id_c % 30),
                    "status": "Active",
                    "lastMilestone": "Initial Setup",
                    "uid": f"UID{1000 + student_id_c}",
                    "rollNumber": f"ROLL{student_id_c:03d}",
                    "campus": DEFAULT_CAMPUS, # Use default campus
                    "photo": f"/static/avatars/student{(student_id_c % 5) + 1}.jpg",
                    "parentPhone": "+91 98765 43210",
                    "joinDate": datetime.now().strftime('%Y-%m-%d'),
                    "roboticsTeam": f"Team {section}",
                    "skills": DEFAULT_SKILLS.copy()
                }
                student['status'] = get_status_from_grade(student['overallGrade'])
                default_data["students"].append(student)
                student_id_c += 1
            class_id_c += 1
    default_data["alerts"] = [
        {"id": "a1", "studentId": "s5", "classId": "c1", "issue": "Low score on Quiz 1", "type": "grade"},
        {"id": "a2", "studentId": "s12", "classId": "c3", "issue": "Overall grade dropped below 60%", "type": "grade"},
        {"id": "a3", "studentId": "s25", "classId": "c5", "issue": "Project 'RoboDesign' overdue", "type": "assignment"}
    ]
    default_data["assignments"] = [
        # Use new 'classIds' list format
        {"id": "as1", "classIds": ["c1"], "title": "Intro Circuit Lab", "dueDate": (datetime.now() + timedelta(days=7)).strftime('%Y-%m-%d'), "totalPoints": 50, "type": "Lab"},
        {"id": "as2", "classIds": ["c1", "c2"], "title": "Unit 1 Test", "dueDate": (datetime.now() + timedelta(days=5)).strftime('%Y-%m-%d'), "totalPoints": 100, "type": "Test"},
        {"id": "as3", "classIds": ["c3"], "title": "Algorithm Quiz", "dueDate": (datetime.now() + timedelta(days=9)).strftime('%Y-%m-%d'), "totalPoints": 20, "type": "Quiz"}
    ]
    default_data["grades"] = {
        "as1": {"s1": 40, "s2": 45, "s3": 35}, # Grades for as1
        "as2": {"s1": 78, "s2": 85, "s4": 91, "s6": 72}, # Grades for as2 (students from c1 and c2)
        "as3": {"s11": 15, "s12": 18} # Grades for as3
    }
    save_data(default_data)
    return default_data

def save_data(data):
    try:
        if not isinstance(data.get('grades'), dict): data['grades'] = {}
        if not isinstance(data.get('assignments'), list): data['assignments'] = []
        if not isinstance(data.get('students'), list): data['students'] = []
        if not isinstance(data.get('classes'), list): data['classes'] = []
        with open(DATA_FILE, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2)
    except Exception as e:
        print(f"Error saving data to {DATA_FILE}: {e}")

def get_status_from_grade(grade):
    if grade is None: return 'N/A'
    if not isinstance(grade, (int, float)): return 'Invalid'
    if grade >= 90: return 'Excellent'
    if grade >= 70: return 'Good'
    if grade >= 60: return 'Needs Help'
    return 'At Risk'

class PDF(FPDF):
    def header(self):
        self.set_font('Helvetica', 'B', 12)
        self.cell(0, 10, 'Robotics Academy - Student Report', new_x=XPos.RIGHT, new_y=YPos.TOP, align='C')
        self.ln(10)
    def footer(self):
        self.set_y(-15)
        self.set_font('Helvetica', 'I', 8)
        self.cell(0, 10, f'Page {self.page_no()}', new_x=XPos.RIGHT, new_y=YPos.TOP, align='C')

# --- Routes ---
@app.route('/')
def dashboard():
    data = load_data()
    selected_grade = request.args.get('grade', '')
    selected_section = request.args.get('section', '')
    all_classes = data.get('classes', [])
    filtered_classes = [c for c in all_classes if (not selected_grade or c.get('grade') == selected_grade) and (not selected_section or c.get('section') == selected_section)]
    all_students = data.get('students', [])
    total_students = len(all_students)
    if total_students > 0:
        valid_grades = [s.get('overallGrade', 0) for s in all_students if isinstance(s, dict) and isinstance(s.get('overallGrade'), (int, float))]
        avg_grade = sum(valid_grades) / len(valid_grades) if valid_grades else 0
        status_counts = {'Excellent': 0, 'Good': 0, 'Needs Help': 0, 'At Risk': 0, 'N/A': 0, 'Invalid': 0}
        for s in all_students:
            if isinstance(s, dict):
                status = get_status_from_grade(s.get('overallGrade'))
                if status not in status_counts: status = 'Invalid'
                status_counts[status] = status_counts.get(status, 0) + 1
    else:
        avg_grade = 0
        status_counts = {k: 0 for k in ['Excellent', 'Good', 'Needs Help', 'At Risk', 'N/A', 'Invalid']}
    alerts_display = []
    class_map = {c.get('id'): c for c in all_classes if isinstance(c, dict)}
    student_map = {s.get('id'): s for s in all_students if isinstance(s, dict)}
    for alert in data.get('alerts', []):
        if not isinstance(alert, dict): continue
        student = student_map.get(alert.get('studentId'))
        class_info = class_map.get(alert.get('classId'))
        if student and class_info:
            alert_copy = alert.copy()
            alert_copy['studentName'] = student.get('name', 'Unknown')
            alert_copy['className'] = f"{class_info.get('name', '')} - {class_info.get('section', '')}"
            alerts_display.append(alert_copy)
    
    # UPDATED: Pass filter lists to dashboard
    available_grades = sorted(set(c.get('grade') for c in all_classes if c.get('grade')))
    available_sections = sorted(set(c.get('section') for c in all_classes if c.get('section')))
    available_campuses = sorted(set(c.get('campus') for c in all_classes if c.get('campus')))

    return render_template('dashboard.html',
                           classes=filtered_classes,
                           all_classes=all_classes,
                           alerts=alerts_display,
                           total_students=total_students,
                           avg_grade=round(avg_grade),
                           status_counts=status_counts,
                           selected_grade=selected_grade,
                           selected_section=selected_section,
                           available_grades=available_grades,
                           available_sections=available_sections,
                           available_campuses=available_campuses, # Pass campuses
                           COMPANY_COLORS=COMPANY_COLORS)

# --- UPDATED /students route ---
@app.route('/students', methods=['GET'])
def students():
    data = load_data()
    all_classes = data.get('classes', [])
    all_students = data.get('students', [])
    class_map = {c.get('id'): c for c in all_classes if isinstance(c, dict)}
    
    processed_students = []
    for student in all_students:
        if not isinstance(student, dict):
            continue
        student_copy = student.copy()
        class_info = class_map.get(student.get('classId'))
        
        # Add separate fields for filtering
        if class_info:
            student_copy['className'] = f"{class_info.get('name', '')} - {class_info.get('section', '')} ({class_info.get('campus', '')})"
            student_copy['gradeName'] = class_info.get('grade', 'unknown')
            student_copy['sectionName'] = class_info.get('section', 'unknown')
            student_copy['campusName'] = class_info.get('campus', 'unknown')
        else:
            student_copy['className'] = 'Unassigned'
            student_copy['gradeName'] = 'unknown'
            student_copy['sectionName'] = 'unknown'
            student_copy['campusName'] = 'unknown'
            
        student_copy['status'] = get_status_from_grade(student.get('overallGrade'))
        processed_students.append(student_copy)
    
    # Gather lists for dropdown filters
    available_grades = sorted(list(set(c.get('grade') for c in all_classes if c.get('grade'))))
    available_sections = sorted(list(set(c.get('section') for c in all_classes if c.get('section'))))
    available_campuses = sorted(list(set(c.get('campus') for c in all_classes if c.get('campus'))))

    response = make_response(render_template('students.html',
                                           students=processed_students,
                                           all_classes=all_classes,
                                           available_grades=available_grades, # Pass grades
                                           sections=available_sections, # Pass sections (matches template)
                                           available_campuses=available_campuses, # Pass campuses
                                           import_summary=None,
                                           import_errors=[]))
    response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
    return response
# --- END UPDATED /students route ---

# --- New Route for /api/get_sections ---
@app.route('/api/get_sections', methods=['GET'])
def get_sections():
    data = load_data()
    sections = sorted(set(c.get('section') for c in data.get('classes', []) if isinstance(c, dict) and c.get('section')))
    return jsonify(sections)

# --- Class Management API Endpoints ---
@app.route('/api/get_classes', methods=['GET'])
def get_classes():
    data = load_data()
    classes = data.get('classes', [])
    return jsonify([c for c in classes if isinstance(c, dict)])

@app.route('/api/get_class/<class_id>', methods=['GET'])
def get_class(class_id):
    data = load_data()
    class_data = next((c for c in data.get('classes', []) if isinstance(c, dict) and c.get('id') == class_id), None)
    if class_data:
        return jsonify(class_data)
    return jsonify({'error': 'Class not found'}), 404

@app.route('/add_class', methods=['POST'])
def add_class():
    data = load_data()
    class_data = request.json
    required_fields = ['name', 'section', 'campus', 'color']
    if not class_data or not all(f in class_data for f in required_fields):
        return jsonify({'success': False, 'message': 'Missing required fields (Name, Section, Campus, Color)'}), 400
    
    # Validate campus
    if class_data['campus'] not in CAMPUSES:
        return jsonify({'success': False, 'message': f"Invalid campus. Must be one of: {', '.join(CAMPUSES)}"}), 400
        
    if class_data['color'] not in COMPANY_COLORS.values():
        return jsonify({'success': False, 'message': 'Invalid color selected'}), 400
    if any(c.get('name') == class_data['name'] and c.get('section') == class_data['section'] and c.get('campus') == class_data['campus'] for c in data.get('classes', []) if isinstance(c, dict)):
        return jsonify({'success': False, 'message': f"Class '{class_data['name']}' with section '{class_data['section']}' at '{class_data['campus']}' already exists"}), 400
    
    highest_id_num = 0
    for c in data.get('classes', []):
        if isinstance(c, dict) and c.get('id', '').startswith('c'):
            try:
                num = int(c['id'][1:])
                highest_id_num = max(highest_id_num, num)
            except ValueError:
                continue
    new_class_id = f"c{highest_id_num + 1}"
    
    # Extract simple grade name (e.g., "6th" from "Grade 6th")
    grade_name = class_data['name'].replace('Grade ', '').strip()

    new_class = {
        'id': new_class_id,
        'name': class_data['name'].strip(),
        'section': class_data['section'].strip(),
        'campus': class_data['campus'].strip(),
        'color': class_data['color'],
        'grade': grade_name, # Store simple grade
        'studentCount': 0
    }
    data['classes'].append(new_class)
    save_data(data)
    print(f"Successfully added class: {new_class_id}")
    return jsonify({'success': True, 'class_id': new_class_id})

@app.route('/edit_class/<class_id>', methods=['POST'])
def edit_class(class_id):
    data = load_data()
    class_data = request.json
    required_fields = ['name', 'section', 'campus', 'color']
    if not class_data or not all(f in class_data for f in required_fields):
        return jsonify({'success': False, 'message': 'Missing required fields (Name, Section, Campus, Color)'}), 400
    
    # Validate campus
    if class_data['campus'] not in CAMPUSES:
        return jsonify({'success': False, 'message': f"Invalid campus. Must be one of: {', '.join(CAMPUSES)}"}), 400
        
    if class_data['color'] not in COMPANY_COLORS.values():
        return jsonify({'success': False, 'message': 'Invalid color selected'}), 400
    
    class_index = -1
    for i, c in enumerate(data.get('classes', [])):
        if isinstance(c, dict) and c.get('id') == class_id:
            class_index = i
            break
    if class_index == -1:
        return jsonify({'success': False, 'message': 'Class not found'}), 404
    
    if any(c.get('name') == class_data['name'] and c.get('section') == class_data['section'] and c.get('campus') == class_data['campus'] and c.get('id') != class_id for c in data.get('classes', []) if isinstance(c, dict)):
        return jsonify({'success': False, 'message': f"Class '{class_data['name']}' with section '{class_data['section']}' at '{class_data['campus']}' already exists"}), 400
    
    # Extract simple grade name
    grade_name = class_data['name'].replace('Grade ', '').strip()

    data['classes'][class_index].update({
        'name': class_data['name'].strip(),
        'section': class_data['section'].strip(),
        'campus': class_data['campus'].strip(),
        'color': class_data['color'],
        'grade': grade_name # Store simple grade
    })
    save_data(data)
    print(f"Successfully updated class: {class_id}")
    return jsonify({'success': True, 'class_id': class_id})

@app.route('/delete_class/<class_id>', methods=['POST'])
def delete_class(class_id):
    data = load_data()
    class_index = -1
    for i, c in enumerate(data.get('classes', [])):
        if isinstance(c, dict) and c.get('id') == class_id:
            class_index = i
            break
    if class_index == -1:
        return jsonify({'success': False, 'message': 'Class not found'}), 404
    
    # Check if class has students
    student_count = 0
    for s in data.get('students', []):
        if isinstance(s, dict) and s.get('classId') == class_id:
            student_count += 1
            break # Found one, that's enough
            
    if student_count > 0:
        return jsonify({'success': False, 'message': 'Cannot delete class with enrolled students. Please reassign students first.'}), 400
        
    data['classes'].pop(class_index)
    # Also delete assignments associated *only* with this class
    data['assignments'] = [a for a in data.get('assignments', []) if not (isinstance(a, dict) and a.get('classIds') == [class_id])]
    # We keep assignments linked to multiple classes, but should we remove this class from their list?
    # For simplicity, we'll only delete assignments that were *only* for this class.
    # We also need to clean grades for those deleted assignments
    deleted_assignment_ids = {a.get('id') for a in data.get('assignments', []) if isinstance(a, dict) and a.get('classIds') == [class_id]}
    data['grades'] = {k: v for k, v in data.get('grades', {}).items() if k not in deleted_assignment_ids}
    
    save_data(data)
    print(f"Successfully deleted class: {class_id}")
    return jsonify({'success': True, 'message': 'Class deleted successfully'})

# --- UPDATED /assignments route ---
@app.route('/assignments')
def assignments():
    data = load_data()
    all_assignments_raw = data.get('assignments', [])
    all_classes = data.get('classes', [])
    class_map = {c.get('id'): c for c in all_classes if isinstance(c, dict)}
    all_grades = data.get('grades', {})
    if not isinstance(all_grades, dict):
        print("Warning: Grades data not dict.")
        all_grades = {}
        
    processed_assignments = []
    for assignment in all_assignments_raw:
        if not isinstance(assignment, dict) or 'id' not in assignment:
            print(f"Skipping invalid: {assignment}")
            continue
            
        assignment_id = assignment['id']
        class_ids = assignment.get('classIds', []) # <-- Get list of IDs
        
        # Get info for all assigned classes
        class_infos = [class_map.get(cid) for cid in class_ids if class_map.get(cid)]
        
        # Store lists of names and colors
        assignment['classNames'] = [f"{c.get('name', '')} - {c.get('section', '')}" for c in class_infos]
        assignment['classColors'] = [c.get('color', 'bg-gray-500') for c in class_infos]
        
        # Calculate stats across ALL assigned students
        assignment_grades_dict = all_grades.get(assignment_id, {})
        valid_grades_list = []
        if isinstance(assignment_grades_dict, dict):
            valid_grades_list = [g for g in assignment_grades_dict.values() if isinstance(g, (int, float))]
            
        graded_count = len(valid_grades_list)
        assignment['averageGrade'] = round(sum(valid_grades_list) / graded_count) if graded_count > 0 else None
        assignment['gradedCount'] = graded_count
        
        processed_assignments.append(assignment)
        
    processed_assignments.sort(key=lambda x: x.get('dueDate', DEFAULT_DATE_SORT_KEY))
    return render_template('assignments.html',
                           assignments=processed_assignments,
                           class_data=None,
                           all_classes=all_classes,
                           assignment_types=ASSIGNMENT_TYPES)
# --- END UPDATED /assignments route ---

# --- UPDATED /gradebook route ---
@app.route('/gradebook')
def gradebook():
    data = load_data()
    all_assignments = data.get('assignments', [])
    all_classes = data.get('classes', [])
    all_students = data.get('students', [])
    all_grades = data.get('grades', {})
    
    class_map = {c.get('id'): c for c in all_classes if isinstance(c, dict)}
    
    assignment_options = []
    for a in all_assignments:
        if isinstance(a, dict):
            a_copy = a.copy()
            # Get count of classes
            class_count = len(a.get('classIds', []))
            a_copy['title'] = f"{a.get('title')} ({class_count} class{'es' if class_count != 1 else ''})"
            assignment_options.append(a_copy)
            
    assignment_options.sort(key=lambda x: x.get('dueDate', DEFAULT_DATE_SORT_KEY), reverse=True)
    
    selected_assignment_id = request.args.get('assignment_id', '')
    selected_class_id = request.args.get('class_id', '')
    
    selected_assignment = None
    selected_class = None
    filtered_students = []
    student_scores = {}
    
    if selected_assignment_id:
        selected_assignment = next((a for a in all_assignments if a.get('id') == selected_assignment_id), None)
    
    if selected_class_id:
        selected_class = next((c for c in all_classes if isinstance(c, dict) and c.get('id') == selected_class_id), None)
        
    if selected_assignment and selected_class:
        # Check if the selected assignment is assigned to the selected class
        if selected_class_id in selected_assignment.get('classIds', []):
            filtered_students = [s for s in all_students if isinstance(s, dict) and s.get('classId') == selected_class_id]
            filtered_students.sort(key=lambda x: x.get('name', ''))
            student_scores = all_grades.get(selected_assignment_id, {})
            if not isinstance(student_scores, dict): student_scores = {}
        else:
            # Assignment doesn't match class, show empty
            selected_assignment = None 
            filtered_students = []
            student_scores = {}
            
    return render_template('gradebook.html',
                           assignment_options=assignment_options,
                           all_classes=all_classes,
                           selected_assignment_id=selected_assignment_id,
                           selected_class_id=selected_class_id,
                           selected_assignment=selected_assignment,
                           selected_class=selected_class,
                           students=filtered_students,
                           scores=student_scores)
# --- END UPDATED /gradebook route ---

@app.route('/settings')
def settings():
    return render_template('settings.html')

@app.route('/search')
def search_students():
    query = request.args.get('q', '').lower()
    data = load_data()
    students = data.get('students', [])
    class_map = {c.get('id'): c for c in data.get('classes', []) if isinstance(c, dict)}
    results = [s for s in students if isinstance(s, dict) and query and (query in s.get('name', '').lower() or query in s.get('email', '').lower() or query in s.get('uid', '').lower())]
    for res in results:
        class_info = class_map.get(res.get('classId'))
        res['className'] = f"{class_info['name']} - {class_info['section']} ({class_info.get('campus', '')})" if class_info else "N/A"
    return jsonify(results)

@app.route('/class/<class_id>')
def class_view(class_id):
    data = load_data()
    current_class = next((c for c in data.get('classes', []) if isinstance(c, dict) and c.get('id') == class_id), None)
    if not current_class:
        return "Class not found", 404
    class_students = [s for s in data.get('students', []) if isinstance(s, dict) and s.get('classId') == class_id]
    
    # Pass campus list for modals
    available_campuses = sorted(list(set(c.get('campus') for c in data.get('classes', []) if c.get('campus'))))
    
    return render_template('class_view.html', 
                           class_data=current_class, 
                           students=class_students,
                           available_campuses=available_campuses) # Pass campuses

# --- UPDATED /student_profile route ---
@app.route('/student/<student_id>')
def student_profile(student_id):
    data = load_data()
    student = next((s for s in data.get('students', []) if isinstance(s, dict) and s.get('id') == student_id), None)
    if not student:
        return "Student not found", 404
    student_class = next((c for c in data.get('classes', []) if isinstance(c, dict) and c.get('id') == student.get('classId')), {})
    student['className'] = f"{student_class.get('name', '')} - {student_class.get('section', '')}"
    student['campus'] = student_class.get('campus', student.get('campus', 'N/A')) # Ensure campus is set
    
    student_assignments_view = []
    all_grades = data.get('grades', {})
    if not isinstance(all_grades, dict):
        all_grades = {}
    all_assignments = data.get('assignments', [])
    if not isinstance(all_assignments, list):
        all_assignments = []
    for assignment in all_assignments:
        if not isinstance(assignment, dict) or 'id' not in assignment:
            continue
        
        # Check if student's class is in the assignment's list
        if student.get('classId') in assignment.get('classIds', []):
            assignment_copy = assignment.copy()
            assignment_grades = all_grades.get(assignment['id'], {})
            if not isinstance(assignment_grades, dict):
                assignment_grades = {}
            student_score = assignment_grades.get(student_id)
            assignment_copy['score'] = student_score
            student_assignments_view.append(assignment_copy)
            
    student_assignments_view.sort(key=lambda x: x.get('dueDate', DEFAULT_DATE_SORT_KEY))
    student['status'] = get_status_from_grade(student.get('overallGrade', 0))
    student['skills'] = student.get('skills', DEFAULT_SKILLS.copy()) # --- UPDATED ---
    all_classes = data.get('classes', [])
    
    # Pass campus list for edit modal
    available_campuses = sorted(list(set(c.get('campus') for c in all_classes if c.get('campus'))))

    return render_template('student_profile.html', 
                           student=student, 
                           assignments=student_assignments_view, 
                           class_data=student_class, 
                           all_classes=all_classes,
                           available_campuses=available_campuses) # Pass campuses
# --- END UPDATED /student_profile route ---

@app.route('/report/student/<student_id>')
def student_report_html(student_id):
    data = load_data()
    student = next((s for s in data.get('students', []) if isinstance(s, dict) and s.get('id') == student_id), None)
    if not student:
        return "Student not found", 404
    student_class = next((c for c in data.get('classes', []) if isinstance(c, dict) and c.get('id') == student.get('classId')), {})
    student['className'] = f"{student_class.get('name', '')} - {student_class.get('section', '')}"
    student['campus'] = student_class.get('campus', student.get('campus', 'N/A'))
    
    student_assignments_view = []
    all_grades = data.get('grades', {})
    if not isinstance(all_grades, dict):
        all_grades = {}
    all_assignments = data.get('assignments', [])
    if not isinstance(all_assignments, list):
        all_assignments = []
    for assignment in all_assignments:
        if not isinstance(assignment, dict) or 'id' not in assignment:
            continue
        
        # Check if student's class is in the assignment's list
        if student.get('classId') in assignment.get('classIds', []):
            assignment_copy = assignment.copy()
            assignment_grades = all_grades.get(assignment['id'], {})
            if not isinstance(assignment_grades, dict):
                assignment_grades = {}
            student_score = assignment_grades.get(student_id)
            assignment_copy['score'] = student_score
            student_assignments_view.append(assignment_copy)
            
    student_assignments_view.sort(key=lambda x: x.get('dueDate', DEFAULT_DATE_SORT_KEY))
    student['status'] = get_status_from_grade(student.get('overallGrade', 0))
    student['skills'] = student.get('skills', DEFAULT_SKILLS.copy()) # --- UPDATED ---
    generation_date = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    return render_template('student_report.html', student=student, assignments=student_assignments_view, generated_date=generation_date)

@app.route('/report/student/<student_id>/pdf')
def student_report_pdf(student_id):
    if not FPDF_AVAILABLE:
        return "PDF generation library (fpdf2) not installed. Please install it: pip install fpdf2", 501
    data = load_data()
    student = next((s for s in data.get('students', []) if isinstance(s, dict) and s.get('id') == student_id), None)
    if not student:
        return "Student not found", 404
    student_class = next((c for c in data.get('classes', []) if isinstance(c, dict) and c.get('id') == student.get('classId')), {})
    student['className'] = f"{student_class.get('name', '')} - {student_class.get('section', '')}"
    student['campus'] = student_class.get('campus', student.get('campus', 'N/A'))

    student_assignments_view = []
    all_grades = data.get('grades', {})
    if not isinstance(all_grades, dict):
        all_grades = {}
    all_assignments = data.get('assignments', [])
    if not isinstance(all_assignments, list):
        all_assignments = []
    for assignment in all_assignments:
        if not isinstance(assignment, dict) or 'id' not in assignment:
            continue
        
        # Check if student's class is in the assignment's list
        if student.get('classId') in assignment.get('classIds', []):
            assignment_copy = assignment.copy()
            assignment_grades = all_grades.get(assignment['id'], {})
            if not isinstance(assignment_grades, dict):
                assignment_grades = {}
            student_score = assignment_grades.get(student_id)
            assignment_copy['score'] = student_score
            student_assignments_view.append(assignment_copy)
            
    student_assignments_view.sort(key=lambda x: x.get('dueDate', DEFAULT_DATE_SORT_KEY))
    student['status'] = get_status_from_grade(student.get('overallGrade', 0))
    student['skills'] = student.get('skills', DEFAULT_SKILLS.copy()) # --- UPDATED ---
    generation_date = datetime.now().strftime('%Y-%m-%d')
    try:
        pdf = PDF(orientation='P', unit='mm', format='A4')
        pdf.add_page()
        pdf.set_auto_page_break(auto=True, margin=15)
        pdf.set_font('Helvetica', 'B', 18)
        pdf.cell(0, 10, student.get('name', 'Unknown Student'), new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='L')
        pdf.set_font('Helvetica', '', 10)
        pdf.cell(0, 6, f"Class: {student.get('className', 'N/A')}", new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='L')
        pdf.cell(0, 6, f"Campus: {student.get('campus', 'N/A')}", new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='L')
        pdf.cell(0, 6, f"UID: {student.get('uid', '-')}", new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='L')
        pdf.cell(0, 6, f"Report Generated: {generation_date}", new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='L')
        pdf.ln(5)
        pdf.set_font('Helvetica', 'B', 14)
        pdf.cell(0, 10, "Overall Performance", new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='L')
        pdf.set_font('Helvetica', '', 10)
        pdf.set_fill_color(248, 250, 252)
        pdf.cell(95, 10, "Overall Grade:", border=1, new_x=XPos.RIGHT, new_y=YPos.TOP, align='L', fill=True)
        pdf.set_font('Helvetica', 'B', 12)
        pdf.cell(95, 10, f"{student.get('overallGrade', 0)}%", border=1, new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='R', fill=True)
        pdf.set_font('Helvetica', '', 10)
        pdf.cell(95, 10, "Status:", border=1, new_x=XPos.RIGHT, new_y=YPos.TOP, align='L', fill=True)
        pdf.set_font('Helvetica', 'B', 12)
        pdf.cell(95, 10, student.get('status', 'N/A'), border=1, new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='R', fill=True)
        pdf.ln(10)
        pdf.set_font('Helvetica', 'B', 14)
        pdf.cell(0, 10, "Basic Information", new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='L')
        pdf.set_font('Helvetica', '', 10)
        pdf.cell(40, 7, "Email:", new_x=XPos.RIGHT, new_y=YPos.TOP)
        pdf.cell(0, 7, student.get('email', '-'), new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='L')
        pdf.cell(40, 7, "Parent Phone:", new_x=XPos.RIGHT, new_y=YPos.TOP)
        pdf.cell(0, 7, student.get('parentPhone', '-'), new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='L')
        pdf.cell(40, 7, "Join Date:", new_x=XPos.RIGHT, new_y=YPos.TOP)
        pdf.cell(0, 7, student.get('joinDate', '-'), new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='L')
        pdf.cell(40, 7, "Robotics Team:", new_x=XPos.RIGHT, new_y=YPos.TOP)
        pdf.cell(0, 7, student.get('roboticsTeam', '-'), new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='L')
        pdf.ln(10)
        pdf.set_font('Helvetica', 'B', 14)
        pdf.cell(0, 10, "Skills", new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='L')
        pdf.set_font('Helvetica', '', 10)
        # --- UPDATED PDF Skills ---
        skills_dict = student.get('skills', {})
        if skills_dict and isinstance(skills_dict, dict):
            for skill_name, rating in skills_dict.items():
                pdf.cell(60, 7, f"{skill_name}:", new_x=XPos.RIGHT, new_y=YPos.TOP, align='L')
                pdf.cell(0, 7, f"{rating} / 5", new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='L')
        else:
            pdf.multi_cell(0, 7, "No skills listed.", align='L')
        # --- END UPDATE ---
        pdf.ln(10)
        if student_assignments_view:
            pdf.add_page()
            pdf.set_font('Helvetica', 'B', 14)
            pdf.cell(0, 10, "Assignments & Scores", new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='L')
            pdf.set_font('Helvetica', 'B', 9)
            pdf.set_fill_color(248, 250, 252)
            col_widths = {'title': 70, 'type': 30, 'due': 25, 'max': 15, 'score': 15, 'pct': 15}
            pdf.cell(col_widths['title'], 7, "Title", border=1, new_x=XPos.RIGHT, new_y=YPos.TOP, align='L', fill=True)
            pdf.cell(col_widths['type'], 7, "Type", border=1, new_x=XPos.RIGHT, new_y=YPos.TOP, align='L', fill=True)
            pdf.cell(col_widths['due'], 7, "Due Date", border=1, new_x=XPos.RIGHT, new_y=YPos.TOP, align='L', fill=True)
            pdf.cell(col_widths['max'], 7, "Max", border=1, new_x=XPos.RIGHT, new_y=YPos.TOP, align='C', fill=True)
            pdf.cell(col_widths['score'], 7, "Score", border=1, new_x=XPos.RIGHT, new_y=YPos.TOP, align='C', fill=True)
            pdf.cell(col_widths['pct'], 7, "%", border=1, new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='C', fill=True)
            pdf.set_font('Helvetica', '', 9)
            fill = False
            for assignment in student_assignments_view:
                pdf.set_fill_color(255, 255, 255) if not fill else pdf.set_fill_color(248, 250, 252)
                pdf.cell(col_widths['title'], 8, str(assignment.get('title', '-'))[:40], border=1, new_x=XPos.RIGHT, new_y=YPos.TOP, align='L', fill=True)
                pdf.cell(col_widths['type'], 8, str(assignment.get('type', '-')), border=1, new_x=XPos.RIGHT, new_y=YPos.TOP, align='L', fill=True)
                pdf.cell(col_widths['due'], 8, str(assignment.get('dueDate', '-')), border=1, new_x=XPos.RIGHT, new_y=YPos.TOP, align='L', fill=True)
                pdf.cell(col_widths['max'], 8, str(assignment.get('totalPoints', '-')), border=1, new_x=XPos.RIGHT, new_y=YPos.TOP, align='C', fill=True)
                score = assignment.get('score')
                score_str = str(score) if score is not None else '-'
                pdf.cell(col_widths['score'], 8, score_str, border=1, new_x=XPos.RIGHT, new_y=YPos.TOP, align='C', fill=True)
                pct_str = '-'
                if score is not None and isinstance(assignment.get('totalPoints'), int) and assignment['totalPoints'] > 0:
                    pct = round((score / assignment['totalPoints']) * 100)
                    pct_str = f"{pct}%"
                pdf.cell(col_widths['pct'], 8, pct_str, border=1, new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='C', fill=True)
                fill = not fill
        else:
            pdf.set_font('Helvetica', 'I', 10)
            pdf.cell(0, 10, "No assignments found for this student's class.", new_x=XPos.LMARGIN, new_y=YPos.NEXT, align='L')
        pdf_bytes = bytes(pdf.output())
        filename = f"Report_{student.get('name', 'Student').replace(' ', '_')}_{datetime.now().strftime('%Y%m%d')}.pdf"
        response = make_response(pdf_bytes)
        response.headers['Content-Type'] = 'application/pdf'
        response.headers['Content-Disposition'] = f'attachment; filename="{filename}"'
        return response
    except Exception as e:
        print(f"Error generating fpdf2 report for {student_id}: {e}")
        return f"Error generating PDF report: {e}", 500

# --- API Endpoints ---
@app.route('/update_grade', methods=['POST'])
def update_grade():
    data = load_data()
    student_id = request.json.get('student_id')
    new_grade_str = request.json.get('new_grade')
    if not student_id or new_grade_str is None:
        return jsonify({'success': False, 'message': 'Missing data'}), 400
    try:
        new_grade = int(new_grade_str)
        assert 0 <= new_grade <= 100
    except (ValueError, AssertionError):
        return jsonify({'success': False, 'message': 'Invalid grade (0-100 required)'}), 400
    student_updated = False
    students_list = data.get('students', [])
    for i, student in enumerate(students_list):
        if isinstance(student, dict) and student.get('id') == student_id:
            students_list[i]['overallGrade'] = new_grade
            students_list[i]['status'] = get_status_from_grade(new_grade)
            student_updated = True
            break
    if student_updated:
        save_data(data)
        return jsonify({'success': True})
    else:
        return jsonify({'success': False, 'message': 'Student not found'}), 404

@app.route('/update_assignment_grade', methods=['POST'])
def update_assignment_grade():
    data = load_data()
    assignment_id = request.json.get('assignment_id')
    student_id = request.json.get('student_id')
    grade_input = request.json.get('grade')
    if not all([assignment_id, student_id]):
        return jsonify({'success': False, 'message': 'Missing ID(s)'}), 400
    assignment = next((a for a in data.get('assignments', []) if isinstance(a, dict) and a.get('id') == assignment_id), None)
    if not assignment:
        return jsonify({'success': False, 'message': 'Assignment not found'}), 404
    if not any(isinstance(s, dict) and s.get('id') == student_id for s in data.get('students', [])):
        return jsonify({'success': False, 'message': 'Student not found'}), 404
    total_points = assignment.get('totalPoints', 100)
    grade_to_save = None
    if grade_input is not None and grade_input != '':
        try:
            grade_num = int(grade_input)
            assert 0 <= grade_num <= total_points
            grade_to_save = grade_num
        except (ValueError, TypeError, AssertionError):
            return jsonify({'success': False, 'message': f'Invalid score. Must be 0-{total_points} or empty.'}), 400
    if not isinstance(data.get('grades'), dict):
        data['grades'] = {}
    if assignment_id not in data['grades'] or not isinstance(data['grades'][assignment_id], dict):
        data['grades'][assignment_id] = {}
    if grade_to_save is not None:
        data['grades'][assignment_id][student_id] = grade_to_save
    elif student_id in data['grades'][assignment_id]:
        del data['grades'][assignment_id][student_id]
    save_data(data)
    return jsonify({'success': True})

# --- UPDATED /add_assignment route ---
@app.route('/add_assignment', methods=['POST'])
def add_assignment():
    data = load_data()
    assignment_data = request.json
    required = ['class_ids', 'title', 'due_date', 'total_points', 'type']
    
    if not assignment_data or not all(f in assignment_data for f in required):
        return jsonify({'success': False, 'message': 'Missing required fields'}), 400
    
    try:
        total_points = int(assignment_data['total_points'])
        assert total_points > 0
    except (ValueError, TypeError, AssertionError):
        return jsonify({'success': False, 'message': 'Total points must be a positive number.'}), 400
    
    if not isinstance(assignment_data.get('title'), str) or not assignment_data['title'].strip():
        return jsonify({'success': False, 'message': 'Title cannot be empty.'}), 400
    
    if not isinstance(assignment_data.get('due_date'), str) or not assignment_data['due_date']:
        return jsonify({'success': False, 'message': 'Due date is required.'}), 400
    
    if assignment_data.get('type') not in ASSIGNMENT_TYPES:
        return jsonify({'success': False, 'message': 'Invalid assignment type.'}), 400
    
    # Validate that all selected classes exist
    class_ids = assignment_data['class_ids']
    if not isinstance(class_ids, list) or len(class_ids) == 0:
        return jsonify({'success': False, 'message': 'Please select at least one class.'}), 400
    
    valid_classes = [c for c in data.get('classes', []) if isinstance(c, dict)]
    valid_class_ids = {c['id'] for c in valid_classes}
    
    for class_id in class_ids:
        if class_id not in valid_class_ids:
            return jsonify({'success': False, 'message': f'Class ID {class_id} not found.'}), 400
    
    if 'assignments' not in data or not isinstance(data['assignments'], list):
        data['assignments'] = []
    
    # Create ONE master assignment
    new_id_num = 1
    existing_ids = {a.get('id') for a in data['assignments'] if isinstance(a, dict)}
    while f"as{new_id_num}" in existing_ids:
        new_id_num += 1
    
    new_assignment_id = f"as{new_id_num}"
    new_assignment = {
        'id': new_assignment_id,
        'classIds': class_ids, # <-- Save the list of class IDs
        'title': assignment_data['title'].strip(),
        'dueDate': assignment_data['due_date'],
        'totalPoints': total_points,
        'type': assignment_data['type']
    }
    
    data['assignments'].append(new_assignment)
    
    save_data(data)
    print(f"Successfully added assignment: {new_assignment_id} for {len(class_ids)} classes")
    return jsonify({
        'success': True, 
        'assignment_id': new_assignment_id, # Return single ID
        'message': f'Assignment created for {len(class_ids)} classes'
    })
# --- END UPDATED /add_assignment route ---

# --- UPDATED add_student route ---
@app.route('/add_student', methods=['POST'])
def add_student():
    data = load_data()
    student_data = request.json
    # Add 'campus' to required fields
    required_fields = ['name', 'email', 'classId', 'uid', 'rollNumber', 'campus']
    if not student_data or not all(f in student_data and student_data[f] for f in required_fields):
        return jsonify({'success': False, 'message': 'Missing required fields (Name, Email, Class, UID, Roll Number, Campus).'}), 400
    
    new_email = student_data['email'].strip().lower()
    new_uid = student_data['uid'].strip()
    new_rollNumber = student_data['rollNumber'].strip()
    new_campus = student_data['campus'].strip()

    # Validate Campus
    if new_campus not in CAMPUSES:
         return jsonify({'success': False, 'message': f"Invalid campus. Must be one of: {', '.join(CAMPUSES)}"}), 400

    if any(isinstance(s, dict) and s.get('email', '').lower() == new_email for s in data.get('students', [])):
        return jsonify({'success': False, 'message': f'Email "{new_email}" already exists.'}), 400
    if any(isinstance(s, dict) and s.get('uid', '').lower() == new_uid.lower() for s in data.get('students', [])):
        return jsonify({'success': False, 'message': f'UID "{new_uid}" already exists.'}), 400
    if any(isinstance(s, dict) and s.get('rollNumber', '').lower() == new_rollNumber.lower() for s in data.get('students', [])):
        return jsonify({'success': False, 'message': f'Roll Number "{new_rollNumber}" already exists.'}), 400
    
    class_info = next((c for c in data.get('classes', []) if isinstance(c, dict) and c.get('id') == student_data.get('classId')), None)
    if not class_info:
        return jsonify({'success': False, 'message': 'Selected class not found.'}), 400
        
    if 'students' not in data or not isinstance(data['students'], list):
        data['students'] = []
        
    highest_id_num = 0
    for s in data['students']:
        if isinstance(s, dict) and s.get('id', '').startswith('s'):
            try:
                num = int(s['id'][1:])
                highest_id_num = max(highest_id_num, num)
            except ValueError:
                continue
    new_student_num = highest_id_num + 1
    new_student_id = f"s{new_student_num}"
    
    new_student = {
        'id': new_student_id,
        'classId': student_data['classId'],
        'name': student_data['name'].strip(),
        'email': new_email,
        'overallGrade': 70,
        'status': get_status_from_grade(70),
        'lastMilestone': 'Account Created',
        'uid': new_uid,
        'rollNumber': new_rollNumber,
        'campus': new_campus, # Use campus from form
        'photo': f"/static/avatars/student{(new_student_num % 5) + 1}.jpg",
        'parentPhone': student_data.get('parentPhone', ''),
        'joinDate': datetime.now().strftime('%Y-%m-%d'),
        'roboticsTeam': f"Team {class_info.get('section', 'Unknown')}",
        'skills': DEFAULT_SKILLS.copy()
    }

    # Update class student count
    for i, c in enumerate(data.get('classes', [])):
        if isinstance(c, dict) and c.get('id') == new_student['classId']:
            data['classes'][i]['studentCount'] = c.get('studentCount', 0) + 1
            break
            
    data['students'].append(new_student)
    save_data(data)
    print(f"Successfully added student: {new_student_id}")
    return jsonify({'success': True, 'student_id': new_student_id})
# --- END UPDATED add_student route ---

# --- UPDATED edit_student route ---
@app.route('/edit_student/<student_id>', methods=['POST'])
def edit_student(student_id):
    data = load_data()
    updated_data = request.json
    if not updated_data:
        return jsonify({'success': False, 'message': 'No data provided'}), 400
    
    student_index = -1
    students_list = data.get('students', [])
    for i, student in enumerate(students_list):
        if isinstance(student, dict) and student.get('id') == student_id:
            student_index = i
            break
    
    if student_index == -1:
        return jsonify({'success': False, 'message': 'Student not found'}), 404
    
    # Add 'campus' to required fields if it's sent from the form
    # Note: student_profile.html modal needs to be updated to send this
    required_fields = ['name', 'email', 'classId', 'uid', 'rollNumber']
    if not all(updated_data.get(field) for field in required_fields):
        return jsonify({'success': False, 'message': 'All fields (Name, Email, Class, UID, Roll Number) are required.'}), 400
    
    new_uid = updated_data['uid'].strip()
    new_roll_number = updated_data['rollNumber'].strip()
    new_email = updated_data['email'].strip().lower()
    # Get new campus, fallback to old campus if not provided
    current_student = students_list[student_index]

    # --- FIX: Safely handle potential None before stripping ---
    campus_value_from_request = updated_data.get('campus')
    if campus_value_from_request is not None:
        # If campus is provided in the request, use it (strip if it's a string)
        new_campus = campus_value_from_request.strip() if isinstance(campus_value_from_request, str) else campus_value_from_request
    else:
        # If campus is NOT in the request, fall back to current student's campus or default
        # No need to strip here as the stored value or default should already be clean
        new_campus = current_student.get('campus', DEFAULT_CAMPUS)

    # Ensure new_campus is not None before validation (it shouldn't be due to fallback)
    if new_campus is None:
        new_campus = DEFAULT_CAMPUS # Extra safety net

    # Validate Campus (make sure it's a string now)
    if not isinstance(new_campus, str) or new_campus not in CAMPUSES:
         # If validation fails after handling None, default it
         print(f"Warning: Invalid campus '{new_campus}' received during edit for student {student_id}. Defaulting to {DEFAULT_CAMPUS}.")
         new_campus = DEFAULT_CAMPUS
    # --- END FIX ---


    # Check for duplicate UID and Roll Number (excluding current student)
    for student in students_list:
        if isinstance(student, dict) and student.get('id') != student_id:
            if student.get('uid', '').strip().lower() == new_uid.lower():
                return jsonify({'success': False, 'message': f'UID "{new_uid}" is already used by {student.get("name")}.'}), 400
            if student.get('rollNumber', '').strip().lower() == new_roll_number.lower():
                return jsonify({'success': False, 'message': f'Roll Number "{new_roll_number}" is already used by {student.get("name")}.'}), 400
            if student.get('email', '').lower() == new_email:
                return jsonify({'success': False, 'message': f'Email "{new_email}" is already used by {student.get("name")}.'}), 400
    
    original_class_id = current_student.get('classId')
    new_class_id = updated_data['classId']
    
    new_skills = updated_data.get('skills', {})
    if not isinstance(new_skills, dict):
        new_skills = current_student.get('skills', DEFAULT_SKILLS.copy())
    
    current_student.update({
        'name': updated_data['name'].strip(),
        'email': new_email,
        'classId': new_class_id,
        'uid': new_uid,
        'rollNumber': new_roll_number,
        'parentPhone': updated_data.get('parentPhone', current_student.get('parentPhone', '')),
        'skills': new_skills,
        'campus': new_campus # Save the updated campus
    })
    
    if original_class_id != new_class_id:
        new_class_info = next((c for c in data.get('classes', []) if c.get('id') == new_class_id), None)
        current_student['roboticsTeam'] = f"Team {new_class_info.get('section', 'Unknown')}" if new_class_info else ''
        
        for i, c in enumerate(data.get('classes', [])):
            if isinstance(c, dict):
                if c.get('id') == original_class_id:
                    data['classes'][i]['studentCount'] = max(0, c.get('studentCount', 1) - 1)
                elif c.get('id') == new_class_id:
                    data['classes'][i]['studentCount'] = c.get('studentCount', 0) + 1
    
    save_data(data)
    print(f"Successfully updated student: {student_id}")
    return jsonify({'success': True, 'student_id': student_id})
# --- END UPDATED edit_student route ---

@app.route('/check_student_duplicates', methods=['POST'])
def check_student_duplicates():
    data = load_data()
    request_data = request.json
    student_id = request_data.get('student_id')
    new_uid = request_data.get('uid', '').strip()
    new_roll_number = request_data.get('roll_number', '').strip()
    
    if not student_id or not new_uid or not new_roll_number:
        return jsonify({'success': False, 'message': 'Missing required fields'}), 400
    
    duplicate_uid = None
    duplicate_roll = None
    
    for student in data.get('students', []):
        if isinstance(student, dict) and student.get('id') != student_id:
            if student.get('uid', '').strip().lower() == new_uid.lower():
                duplicate_uid = student.get('name', 'Unknown Student')
            
            if student.get('rollNumber', '').strip().lower() == new_roll_number.lower():
                duplicate_roll = student.get('name', 'Unknown Student')
    
    has_duplicates = duplicate_uid is not None or duplicate_roll is not None
    
    return jsonify({
        'success': True,
        'has_duplicates': has_duplicates,
        'duplicate_uid': duplicate_uid,
        'duplicate_roll': duplicate_roll
    })

@app.route('/delete_student/<student_id>', methods=['POST'])
def delete_student(student_id):
    data = load_data()
    students_list = data.get('students', [])
    initial_len = len(students_list)
    original_class_id = None
    student_found = False
    data['students'] = []
    for student in students_list:
        if isinstance(student, dict) and student.get('id') == student_id:
            original_class_id = student.get('classId')
            student_found = True
        else:
            data['students'].append(student)
    if not student_found:
        return jsonify({'success': False, 'message': 'Student not found'}), 404
    grades_dict = data.get('grades', {})
    if isinstance(grades_dict, dict):
        for assignment_id in list(grades_dict.keys()):
            if isinstance(grades_dict[assignment_id], dict) and student_id in grades_dict[assignment_id]:
                del grades_dict[assignment_id][student_id]
    if original_class_id:
        for i, c in enumerate(data.get('classes', [])):
            if isinstance(c, dict) and c.get('id') == original_class_id:
                data['classes'][i]['studentCount'] = max(0, c.get('studentCount', 1) - 1)
                break
    save_data(data)
    print(f"Successfully deleted student: {student_id}")
    return jsonify({'success': True, 'message': 'Student deleted successfully'})

@app.route('/delete_students_bulk', methods=['POST'])
def delete_students_bulk():
    data = load_data()
    student_ids = request.json.get('student_ids', [])
    if not student_ids or not isinstance(student_ids, list):
        return jsonify({'success': False, 'message': 'Invalid or missing student_ids list'}), 400
    students_list = data.get('students', [])
    grades_dict = data.get('grades', {})
    class_counts = {}
    deleted_count = 0
    not_found_ids = []
    valid_student_ids = {s.get('id') for s in students_list if isinstance(s, dict)}
    for student_id in student_ids:
        if student_id not in valid_student_ids:
            not_found_ids.append(student_id)
            continue
        student = next((s for s in students_list if isinstance(s, dict) and s.get('id') == student_id), None)
        if not student:
            not_found_ids.append(student_id)
            continue
        original_class_id = student.get('classId')
        if original_class_id:
            class_counts[original_class_id] = class_counts.get(original_class_id, 0) + 1
        if isinstance(grades_dict, dict):
            for assignment_id in list(grades_dict.keys()):
                if isinstance(grades_dict[assignment_id], dict) and student_id in grades_dict[assignment_id]:
                    del grades_dict[assignment_id][student_id]
        deleted_count += 1
    data['students'] = [s for s in students_list if isinstance(s, dict) and s.get('id') not in set(student_ids)]
    for class_id, count in class_counts.items():
        for i, c in enumerate(data.get('classes', [])):
            if isinstance(c, dict) and c.get('id') == class_id:
                data['classes'][i]['studentCount'] = max(0, c.get('studentCount', 1) - count)
                break
    save_data(data)
    message = f"Successfully deleted {deleted_count} students."
    if not_found_ids:
        message += f" {len(not_found_ids)} student(s) not found: {', '.join(not_found_ids)}."
    print(f"Bulk delete: {message}")
    return jsonify({
        'success': True if deleted_count > 0 else False,
        'message': message,
        'deleted_count': deleted_count,
        'not_found_ids': not_found_ids
    })

# --- UPDATED /delete_assignment route ---
@app.route('/delete_assignment', methods=['POST'])
def delete_assignment():
    data = load_data()
    assignment_id = request.json.get('assignment_id')
    if not assignment_id:
        return jsonify({'success': False, 'message': 'Missing assignment ID'}), 400
    
    initial_len = len(data.get('assignments', []))
    # This logic is still correct. It finds the one master assignment and removes it.
    data['assignments'] = [a for a in data.get('assignments', []) if not (isinstance(a, dict) and a.get('id') == assignment_id)]
    
    # This logic is also still correct. It removes the entire gradebook for that master assignment.
    if assignment_id in data.get('grades', {}):
        del data['grades'][assignment_id]
        
    if len(data.get('assignments', [])) < initial_len:
        save_data(data)
        return jsonify({'success': True, 'message': 'Assignment deleted'})
    else:
        return jsonify({'success': False, 'message': 'Assignment not found'}), 404
# --- END UPDATED /delete_assignment route ---


# --- UPDATED export_student_template route ---
@app.route('/export/student_template_csv')
def export_student_template():
    data = load_data()
    all_classes = data.get('classes', [])
    si = io.StringIO()
    writer = csv.writer(si)
    
    # Add 'Campus' to headers
    headers = ['UID', 'Student Name', 'Email', 'Parent Phone', 'Class Name', 'Section', 'Campus']
    writer.writerow(headers)
    writer.writerow(['KYC041JO', 'Example Student', 'example@school.edu', '+919876543210', 'Grade 8', 'Adobe', 'Yamuna Campus'])
    writer.writerow([])
    writer.writerow(["--- VALID OPTIONS (Use these exact names for 'Class Name', 'Section', 'Campus') ---"])
    writer.writerow(["Valid Class Names:", "Valid Sections:", "Valid Campuses:"])
    
    valid_class_names = sorted(list(set(c.get('name') for c in all_classes if c.get('name'))))
    valid_sections = sorted(list(set(c.get('section') for c in all_classes if c.get('section'))))
    valid_campuses = CAMPUSES # Use the constant
    
    max_rows = max(len(valid_class_names), len(valid_sections), len(valid_campuses))
    for i in range(max_rows):
        class_name = valid_class_names[i] if i < len(valid_class_names) else ""
        section = valid_sections[i] if i < len(valid_sections) else ""
        campus = valid_campuses[i] if i < len(valid_campuses) else ""
        writer.writerow([class_name, section, campus])
        
    output = make_response(si.getvalue())
    output.headers["Content-Disposition"] = "attachment; filename=student_import_template.csv"
    output.headers["Content-type"] = "text/csv"
    return output
# --- END UPDATED route ---

# --- UPDATED: /upload_students_csv ---
@app.route('/upload_students_csv', methods=['POST'])
def upload_students_csv():
    if 'student_csv' not in request.files:
        return jsonify({'success': False, 'message': 'No file part found. Please select a CSV.'}), 400
    
    file = request.files['student_csv']
    
    if file.filename == '':
        return jsonify({'success': False, 'message': 'No file selected.'}), 400
    
    if file and file.filename.endswith('.csv'):
        data = load_data()
        all_students = data.get('students', [])
        all_classes = data.get('classes', [])
        class_lookup = {(c.get('name', '').lower(), c.get('section', '').lower(), c.get('campus', '').lower()): c.get('id') for c in all_classes if isinstance(c, dict)}
        uid_lookup = {s.get('uid', '').lower(): s for s in all_students if isinstance(s, dict) and s.get('uid')}
        email_lookup = {s.get('email', '').lower(): s for s in all_students if isinstance(s, dict) and s.get('email')}
        
        highest_id_num = 0
        for s in all_students:
            if isinstance(s, dict) and s.get('id', '').startswith('s'):
                try:
                    num = int(s['id'][1:])
                    highest_id_num = max(highest_id_num, num)
                except ValueError:
                    continue
        
        new_students = []
        errors = []
        success_count = 0
        
        try:
            stream = io.StringIO(file.stream.read().decode("UTF-8"), newline=None)
            csv_reader = csv.DictReader(stream)
            
            for i, row in enumerate(csv_reader):
                line_num = i + 2
                row_headers = {(k or '').lower().strip().replace('\ufeff', ''): v for k, v in row.items()}
                
                uid = row_headers.get('uid', '').strip()
                name = row_headers.get('student name', '').strip()
                email = row_headers.get('email', '').strip().lower()
                class_name_raw = row_headers.get('class name', '').strip()
                section_raw = row_headers.get('section', '').strip()
                campus_raw = row_headers.get('campus', '').strip()
                
                if not uid or not name or not email or not class_name_raw or not section_raw:
                    errors.append(f"Row {line_num}: Missing required field (UID, Student Name, Email, Class Name, or Section).")
                    continue
                
                # Validate or default campus
                if not campus_raw:
                    campus = DEFAULT_CAMPUS
                elif campus_raw.lower() not in [c.lower() for c in CAMPUSES]:
                    errors.append(f"Row {line_num}: Invalid campus '{campus_raw}'. Defaulting to {DEFAULT_CAMPUS}.")
                    campus = DEFAULT_CAMPUS
                else:
                    # Find the correct capitalization
                    campus = next(c for c in CAMPUSES if c.lower() == campus_raw.lower())

                if uid.lower() in uid_lookup:
                    errors.append(f"Row {line_num}: UID '{uid}' already exists for student {uid_lookup[uid.lower()].get('name')}.")
                    continue
                
                if email in email_lookup:
                    errors.append(f"Row {line_num}: Email '{email}' already exists for student {email_lookup[email].get('name')}.")
                    continue
                
                # Update class_lookup to include campus
                class_key = (class_name_raw.lower(), section_raw.lower(), campus.lower())
                class_id = class_lookup.get(class_key)
                
                if not class_id:
                    errors.append(f"Row {line_num}: Class combination not found: {class_name_raw} - {section_raw} - {campus}.")
                    continue
                
                highest_id_num += 1
                new_student_id = f"s{highest_id_num}"
                new_roll = f"ROLL{highest_id_num:03d}"
                
                new_student = {
                    'id': new_student_id,
                    'classId': class_id,
                    'name': name,
                    'email': email,
                    'overallGrade': 70,
                    'status': get_status_from_grade(70),
                    'lastMilestone': 'Bulk Imported',
                    'uid': uid,
                    'rollNumber': new_roll,
                    'campus': campus, # Save correct campus
                    'photo': f"/static/avatars/student{(highest_id_num % 5) + 1}.jpg",
                    'parentPhone': row_headers.get('parent phone', ''),
                    'joinDate': datetime.now().strftime('%Y-%m-%d'),
                    'roboticsTeam': f"Team {section_raw}",
                    'skills': DEFAULT_SKILLS.copy()
                }
                
                new_students.append(new_student)
                uid_lookup[uid.lower()] = new_student
                email_lookup[email] = new_student
                success_count += 1
            
            if new_students:
                data['students'].extend(new_students)
                class_counts = {}
                for s in data['students']:
                    if isinstance(s, dict):
                        cid = s.get('classId')
                        class_counts[cid] = class_counts.get(cid, 0) + 1
                for i, c in enumerate(data['classes']):
                    if isinstance(c, dict):
                        data['classes'][i]['studentCount'] = class_counts.get(c.get('id'), 0)
                save_data(data)
            
            summary = f"Import complete: {success_count} students added."
            if errors:
                summary += f" {len(errors)} rows had warnings/errors."
            
            print(f"CSV Import Summary: {summary}")
            if errors:
                print("CSV Import Errors/Warnings:")
                [print(f"- {e}") for e in errors]
            
            return jsonify({
                'success': True,
                'message': summary,
                'errors': errors
            })
            
        except Exception as e:
            print(f"Error processing CSV file: {e}")
            return jsonify({
                'success': False,
                'message': f'An unexpected error occurred: {e}',
                'errors': [str(e)]
            }), 500
    else:
        return jsonify({
            'success': False,
            'message': 'Invalid file type. Please upload a .csv file.',
            'errors': ['Invalid file type']
        }), 400
# --- END UPDATE ---

@app.route('/get_student_details')
def get_student_details():
    student_id = request.args.get('student_id')
    if not student_id:
        return jsonify({'error': 'ID required'}), 400
    data = load_data()
    student = next((s for s in data.get('students', []) if isinstance(s, dict) and s.get('id') == student_id), None)
    if student:
        class_info = next((c for c in data.get('classes', []) if isinstance(c, dict) and c.get('id') == student.get('classId')), {})
        student['className'] = f"{class_info.get('name', '')} - {class_info.get('section', '')}"
        student['campus'] = class_info.get('campus', student.get('campus', 'N/A')) # Ensure campus is set
        student['status'] = get_status_from_grade(student.get('overallGrade', 0))
        student['skills'] = student.get('skills', DEFAULT_SKILLS.copy())
        return jsonify(student)
    else:
        return jsonify({'error': 'Student not found'}), 404

@app.route('/export_grades/<class_id>')
def export_grades(class_id):
    data = load_data()
    class_info = next((c for c in data.get('classes', []) if isinstance(c, dict) and c.get('id') == class_id), None)
    if not class_info:
        return "Class not found", 404
    filename = f"overall_grades_{class_info.get('grade', '')}_{class_info.get('section', '')}_{datetime.now().strftime('%Y%m%d')}.csv"
    filepath = os.path.join('.', filename)
    try:
        with open(filepath, 'w', newline='', encoding='utf-8') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(['Student Name', 'Email', 'Overall Grade', 'Status', 'UID', 'Roll Number', 'Campus']) # Added Campus
            for student in data.get('students', []):
                if isinstance(student, dict) and student.get('classId') == class_id:
                    writer.writerow([student.get(k, '') for k in ['name', 'email', 'overallGrade', 'status', 'uid', 'rollNumber', 'campus']])
        resp = send_file(filepath, as_attachment=True, download_name=filename)
        try:
            os.remove(filepath)
        except OSError as e:
            print(f"Error removing export file {filepath}: {e}")
        return resp
    except Exception as e:
        print(f"Error exporting grades: {e}")
        if os.path.exists(filepath):
            try:
                os.remove(filepath)
            except OSError as e_rem:
                print(f"Error removing file after export error {filepath}: {e_rem}")
        return "Error creating export file.", 500

@app.route('/reset_data', methods=['POST'])
def reset_data():
    try:
        create_default_data()
        return jsonify({'success': True, 'message': 'Data reset to default'})
    except Exception as e:
        print(f"Error during data reset: {e}")
        return jsonify({'success': False, 'message': f'An error occurred: {e}'}), 500

app.jinja_env.globals.update(get_status_from_grade=get_status_from_grade)

if __name__ == '__main__':
    load_data()
    app.run(debug=True, host='0.0.0.0', port=5000)

