// Initialize all page functionality when DOM is fully loaded
document.addEventListener('DOMContentLoaded', function() {
    initializeSidebarToggle();
    initializeSearchFunctionality();
    initializePageSpecificFeatures();
    initializeAssignmentFormListener();
    initializeResetModalListeners();
    initializeStudentModalListeners(); // Handles general modal close behavior
    initializeDropdownListeners();
    initializeAddStudentFormListener();
    initializeEditStudentFormListener(); // Will attach if #editStudentForm exists
    initializeImportStudentsFormListener();
    initializeBulkStudentActions();
});

// --- Utility Functions ---
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// Global fetch wrapper with error handling and JSON parsing
async function fetchWithErrorHandling(url, options = {}) {
    // Default headers, can be overridden by options.headers
    const defaultHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json' // Expect JSON response
    };

    // Merge headers, prioritizing options.headers
    const mergedHeaders = { ...defaultHeaders, ...options.headers };

    // Special case: FormData (e.g., file upload)
    // Let the browser set the Content-Type for FormData
    if (options.body instanceof FormData) {
        delete mergedHeaders['Content-Type']; // Browser will set this with boundary
    }

    try {
        const response = await fetch(url, {
            ...options,
            headers: mergedHeaders // Use merged headers
        });

        const contentType = response.headers.get("content-type");
        let responseData;

        if (contentType && contentType.includes("application/json")) {
            responseData = await response.json();
        } else {
            // Handle non-JSON responses gracefully (e.g., plain text or HTML error pages)
            const textResponse = await response.text();
            if (!response.ok) {
                // If it's an error and not JSON, create a structured error object
                throw new Error(`HTTP error! Status: ${response.status}. Response: ${textResponse}`);
            }
            // If it's successful but not JSON, return the text
            console.warn(`Unexpected non-JSON response from ${url}. Content-Type: ${contentType}`);
            // Return in a consistent format
            return { success: true, data: textResponse };
        }

        if (!response.ok) {
            // If it IS JSON but not ok, use the message from JSON if available
            const errorMessage = responseData.message || `HTTP error! Status: ${response.status}`;
            throw new Error(errorMessage);
        }

        return responseData; // Return parsed JSON data (which should have {success: ...})

    } catch (error) {
        console.error(`Fetch error for ${url}:`, error);
        // Do not show a toast here, let the calling function handle it
        throw error; // Re-throw the error for specific handling in the calling function
    }
}


function showToast(message, type = 'success') {
    const toastContainer = document.getElementById('toast-container') || createToastContainer();
    const iconClass = type === 'success' ? 'fa-check-circle' : type === 'error' ? 'fa-exclamation-triangle' : 'fa-info-circle';
    const bgColor = type === 'success' ? 'bg-green-500' : type === 'error' ? 'bg-red-600' : 'bg-blue-500';

    const toast = document.createElement('div');
    toast.className = `p-3 rounded-lg shadow-md text-white text-sm ${bgColor} flex items-center transform transition-all duration-300 translate-x-full opacity-0 mb-2`;
    toast.innerHTML = `<i class="fas ${iconClass} mr-2"></i><span>${message}</span>`;
    toast.setAttribute('role', 'alert'); // Accessibility

    toastContainer.prepend(toast); // Add new toasts to the top

    // Animate in
    requestAnimationFrame(() => {
        toast.classList.remove('translate-x-full', 'opacity-0');
        toast.classList.add('translate-x-0', 'opacity-100');
    });

    // Set timeout to animate out and remove
    setTimeout(() => {
        toast.classList.remove('translate-x-0', 'opacity-100');
        toast.classList.add('opacity-0');
        // Remove element after transition completes
        toast.addEventListener('transitionend', () => {
            if (toast.parentNode) toast.remove();
            // Remove container if empty
            if (toastContainer.children.length === 0) {
                 toastContainer.remove();
            }
        }, { once: true }); // Ensure listener runs only once
    }, 4000); // Duration toast is visible
}


function createToastContainer() {
    let container = document.getElementById('toast-container');
    if (!container) {
        container = document.createElement('div');
        container.id = 'toast-container';
        // Position fixed, top-right, with z-index, width, and spacing
        container.className = 'fixed top-4 right-4 z-[100] w-64 space-y-2';
        document.body.appendChild(container);
    }
    return container;
}


function setLoadingState(element, isLoading, originalHTMLContent = 'Submit') {
    if (!element) return;
    const spinnerIcon = '<i class="fas fa-spinner fa-spin mr-2"></i>';
    if (isLoading) {
        element.disabled = true;
        // Store original content if not already stored
        if (!element.dataset.originalContent) {
            element.dataset.originalContent = element.innerHTML; // Store full HTML
        }
        element.innerHTML = `${spinnerIcon}Working...`;
    } else {
        element.disabled = false;
        // Restore original content from data attribute or use provided default
        element.innerHTML = element.dataset.originalContent || originalHTMLContent; // Restore full HTML
        // Clear the stored content
        delete element.dataset.originalContent;
    }
}


function getStatusInfoFromGrade(grade) {
    // Handles null, undefined, NaN, and string representations
    const gradeNum = grade !== null && grade !== undefined && !isNaN(parseInt(grade)) ? parseInt(grade) : null;

    if (gradeNum === null) {
        return { text: 'N/A', classes: 'bg-gray-100 text-gray-800' };
    }

    if (gradeNum >= 90) return { text: 'Excellent', classes: 'bg-green-100 text-green-800' };
    if (gradeNum >= 70) return { text: 'Good', classes: 'bg-blue-100 text-blue-800' };
    if (gradeNum >= 60) return { text: 'Needs Help', classes: 'bg-yellow-100 text-yellow-800' };
    return { text: 'At Risk', classes: 'bg-red-100 text-red-800' };
}


function showNotImplementedToast(feature = 'This feature') {
    showToast(`${feature} is not yet implemented.`, 'info'); // Changed type to 'info'
}


// --- Sidebar ---
function initializeSidebarToggle() {
    const sidebar = document.getElementById('sidebar');
    const toggleBtn = document.getElementById('sidebarToggle');
    const toggleIcon = document.getElementById('toggleIcon');
    const overlay = document.getElementById('overlay');

    if (!sidebar || !toggleBtn || !toggleIcon || !overlay) {
        console.warn("Sidebar toggle elements not fully found. Sidebar functionality may be limited.");
        return;
    }

    // Function to update sidebar state based on 'collapsed' class
    const updateSidebarState = (shouldBeCollapsed) => {
        sidebar.classList.toggle('collapsed', shouldBeCollapsed);
        toggleIcon.className = shouldBeCollapsed ? 'fas fa-bars' : 'fas fa-times'; // Correct icon logic
        if (window.innerWidth <= 768) { // Only manage overlay and body scroll on mobile
            overlay.classList.toggle('active', !shouldBeCollapsed);
            document.body.style.overflow = shouldBeCollapsed ? '' : 'hidden';
        } else { // Ensure overlay and scroll lock are off on desktop
            overlay.classList.remove('active');
            document.body.style.overflow = '';
        }
        // Save state to localStorage
        localStorage.setItem('sidebarCollapsed', shouldBeCollapsed);
    };

    // Initialize sidebar state from localStorage on page load
    const isInitiallyCollapsed = localStorage.getItem('sidebarCollapsed') === 'true';
    updateSidebarState(isInitiallyCollapsed);

    // Toggle sidebar on button click
    toggleBtn.addEventListener('click', function() {
        const currentlyCollapsed = sidebar.classList.contains('collapsed');
        updateSidebarState(!currentlyCollapsed); // Toggle the state
    });

    // Close sidebar on overlay click (only relevant on mobile)
    overlay.addEventListener('click', function() {
        updateSidebarState(true); // Collapse the sidebar
    });

    // Close sidebar on nav item click (mobile only)
    document.querySelectorAll('#sidebar .nav-item').forEach(item => {
        item.addEventListener('click', function() {
            if (window.innerWidth <= 768 && !sidebar.classList.contains('collapsed')) {
                 updateSidebarState(true); // Collapse the sidebar
            }
            // Allow navigation to proceed
        });
    });

    // Handle resize to correctly manage overlay and scroll lock
    window.addEventListener('resize', function() {
        const isCollapsed = sidebar.classList.contains('collapsed');
        // Re-apply state logic on resize
        updateSidebarState(isCollapsed);
    });

    // Close sidebar on Escape key press
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && !sidebar.classList.contains('collapsed')) {
             updateSidebarState(true); // Collapse the sidebar
        }
    });
}


// --- Search ---
function initializeSearchFunctionality() {
    const searchInput = document.getElementById('studentSearch'); // Assuming ID from dashboard.html
    const resultsContainer = document.getElementById('searchResults');

    if (!searchInput || !resultsContainer) {
        // console.warn("Student search elements not found. Search may not work on this page.");
        return; // Exit if elements aren't present on the current page
    }

    // Debounced search function
    const performSearch = debounce(async (query) => {
        resultsContainer.innerHTML = ''; // Clear previous results immediately

        if (query.length < 2) { // Minimum characters to trigger search
            resultsContainer.classList.add('hidden');
            return;
        }

        // Show loading state
        resultsContainer.innerHTML = '<div class="p-4 text-center text-gray-500 text-sm"><i class="fas fa-spinner fa-spin mr-2"></i>Searching...</div>';
        resultsContainer.classList.remove('hidden');

        try {
            // Use fetchWithErrorHandling for robust API calls
            const students = await fetchWithErrorHandling(`/search?q=${encodeURIComponent(query)}`);
            // Assuming `students` is the array from the JSON response
            displaySearchResults(students, query, resultsContainer);
        } catch (error) {
            // Error handled by fetchWithErrorHandling, just display message
            console.error("Search failed:", error);
            showSearchError(resultsContainer, 'Search failed. Please try again.');
        }
    }, 300); // 300ms delay

    // Event listener for input changes
    searchInput.addEventListener('input', (e) => {
        performSearch(e.target.value.trim());
    });

    // Clear results and hide when clicking outside
    document.addEventListener('click', (e) => {
        // Hide if the click is outside the input and the results container
        if (!searchInput.contains(e.target) && !resultsContainer.contains(e.target)) {
            resultsContainer.classList.add('hidden');
        }
    });

    // Hide results on Escape key
    searchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            resultsContainer.classList.add('hidden');
            searchInput.blur(); // Remove focus from input
        }
    });
}


function displaySearchResults(students, query, container) {
    if (students && Array.isArray(students) && students.length > 0) {
        container.innerHTML = students.map(student => {
            // Basic check for essential student properties
            const studentId = student.id || '#';
            const studentName = student.name || 'Unknown Student';
            const studentEmail = student.email || 'No email';
            const studentClass = student.className || 'N/A';
            const studentGrade = student.overallGrade !== undefined && student.overallGrade !== null ? `${student.overallGrade}%` : 'N/A';

            return `
            <a href="/student/${studentId}" class="block p-3 border-b border-gray-100 last:border-b-0 hover:bg-blue-50 transition-colors duration-150 group">
                <div class="flex items-center justify-between">
                    <div>
                        <p class="font-semibold text-gray-800 text-sm group-hover:text-blue-700">${studentName}</p>
                        <p class="text-xs text-gray-600">${studentEmail}</p>
                        <p class="text-xs text-gray-500 mt-1">Class: ${studentClass} • Grade: ${studentGrade}</p>
                    </div>
                    <i class="fas fa-chevron-right text-gray-400 text-xs group-hover:text-blue-600 transition-colors"></i>
                </div>
            </a>
            `;
        }).join('');
    } else {
        // Display no results message
        showNoResults(container, query);
    }
    // Ensure container is visible if there are results or a "no results" message
    container.classList.remove('hidden');
}


function showNoResults(container, query) {
    container.innerHTML = `<div class="p-4 text-center text-gray-500 text-sm"><i class="fas fa-search mr-2 opacity-50"></i>No results found for "${query}"</div>`;
    container.classList.remove('hidden');
}


function showSearchError(container, message) {
    container.innerHTML = `<div class="p-4 text-center text-red-600 text-sm"><i class="fas fa-exclamation-triangle mr-2"></i>${message}</div>`;
    container.classList.remove('hidden');
}


// --- Grade/Score Update Functions ---

// Updates the OVERALL grade for a student (typically from students.html)
async function updateGrade(studentId, newGrade, event) {
    const inputElement = event ? event.target : null;
    let gradeNum;

    // Validate input: must be a number between 0 and 100
    if (newGrade === null || String(newGrade).trim() === '') {
        showToast('Overall grade cannot be empty.', 'error');
        if (inputElement) inputElement.focus(); // Keep focus if invalid
        return;
    }

    gradeNum = parseInt(newGrade);
    if (isNaN(gradeNum) || gradeNum < 0 || gradeNum > 100) {
        showToast('Overall grade must be an integer between 0 and 100.', 'error');
        if (inputElement) inputElement.focus(); // Keep focus if invalid
        return;
    }

    // Visual feedback: Indicate processing
    if (inputElement) {
        inputElement.classList.remove('border-red-500', 'border-green-500'); // Clear previous status
        inputElement.classList.add('border-yellow-500', 'animate-pulse'); // Yellow border + pulse
        inputElement.disabled = true; // Prevent further edits while saving
    }

    try {
        const result = await fetchWithErrorHandling('/update_grade', {
            method: 'POST',
            body: JSON.stringify({ student_id: studentId, new_grade: gradeNum })
        });

        if (result.success) {
            showToast('Overall grade updated!', 'success');
            if (inputElement) {
                // Visual feedback: Success
                inputElement.classList.remove('border-yellow-500', 'animate-pulse');
                inputElement.classList.add('border-green-500', 'bg-green-50/50');
                // Update the status badge in the table row
                updateStatusBadge(studentId, gradeNum);
                // Update the row's data attribute for filtering consistency
                const row = inputElement.closest('tr');
                if (row) row.dataset.grade = gradeNum; // Update data-grade attribute

                // Remove success feedback after a short delay
                setTimeout(() => {
                    inputElement.classList.remove('border-green-500', 'bg-green-50/50');
                }, 1500);
            }
        } else {
            // Throw error using message from server response
            throw new Error(result.message || 'Update failed on server.');
        }
    } catch (error) {
        console.error('Error updating overall grade:', error);
        showToast(`Error: ${error.message}`, 'error');
        if (inputElement) {
            // Visual feedback: Error
            inputElement.classList.remove('border-yellow-500', 'animate-pulse');
            inputElement.classList.add('border-red-500');
            // Optionally revert the value
            const row = inputElement.closest('tr');
            if (row && row.dataset.grade) {
                inputElement.value = row.dataset.grade;
            }
        }
    } finally {
        // Always re-enable the input after the operation
        if (inputElement) inputElement.disabled = false;
    }
}


// Updates a specific ASSIGNMENT score for a student (typically from gradebook.html)
async function updateAssignmentGrade(assignmentId, studentId, score, event, totalPoints) {
    const inputElement = event ? event.target : null;
    let scoreToSave = null; // Represents 'ungraded' if input is empty

    // Ensure totalPoints is a valid positive number for validation
    const maxPoints = (typeof totalPoints === 'number' && totalPoints > 0) ? totalPoints : 100; // Default max if invalid

    // Validate score input if provided
    if (score !== null && String(score).trim() !== '') {
        const scoreNum = parseInt(score); // Assuming integer scores

        if (isNaN(scoreNum) || scoreNum < 0 || scoreNum > maxPoints) {
            showToast(`Score must be an integer between 0 and ${maxPoints}, or empty.`, 'error');
            if (inputElement) inputElement.focus(); // Keep focus if invalid
            return;
        }
        scoreToSave = scoreNum; // Valid score to save
    }

    // Visual feedback: Indicate processing
    if (inputElement) {
        inputElement.classList.remove('border-red-500', 'border-green-500'); // Clear previous status
        inputElement.classList.add('border-yellow-500', 'animate-pulse'); // Yellow border + pulse
        inputElement.disabled = true; // Prevent further edits
    }

    try {
        const result = await fetchWithErrorHandling('/update_assignment_grade', {
            method: 'POST',
            body: JSON.stringify({ assignment_id: assignmentId, student_id: studentId, grade: scoreToSave })
        });

        if (result.success) {
            showToast('Score updated!', 'success');
            if (inputElement) {
                // Visual feedback: Success
                inputElement.classList.remove('border-yellow-500', 'animate-pulse');
                inputElement.classList.add('border-green-500', 'bg-green-50/50');
                // Update percentage and status cells in the same row
                updateAssessmentRow(inputElement.closest('tr'), scoreToSave, maxPoints); // Use maxPoints

                // Remove success feedback after delay
                setTimeout(() => {
                    inputElement.classList.remove('border-green-500', 'bg-green-50/50');
                }, 1500);
            }
        } else {
            // Throw error using message from server
            throw new Error(result.message || 'Update failed on server.');
        }
    } catch (error) {
        console.error('Error updating assignment grade:', error);
        showToast(`Error: ${error.message}`, 'error');
        if (inputElement) {
            // Visual feedback: Error
            inputElement.classList.remove('border-yellow-500', 'animate-pulse');
            inputElement.classList.add('border-red-500');
        }
    } finally {
        // Always re-enable input
        if (inputElement) inputElement.disabled = false;
    }
}


function updateStatusBadge(studentId, grade) {
    // Find the row corresponding to the student
    const row = document.querySelector(`tr[data-student-id="${studentId}"]`);
    if (!row) {
        // console.warn(`Could not find row for student ${studentId} to update status badge.`);
        return;
    }

    // Find the specific cell containing the status badge
    const statusCell = row.querySelector('.status-cell'); // Assuming the cell has class 'status-cell'
    if (!statusCell) {
        // console.warn(`Could not find status cell in row for student ${studentId}.`);
        return;
    }

    // Get the status text and CSS classes based on the grade
    const statusInfo = getStatusInfoFromGrade(grade);

    // Update the inner HTML of the status cell
    statusCell.innerHTML = `
        <span class="px-2.5 py-0.5 inline-flex text-xs leading-5 font-semibold rounded-full ${statusInfo.classes} status-badge">
            ${statusInfo.text}
        </span>
    `;

    // Also update the row's data-status attribute for filtering consistency
    if (row.dataset.status !== undefined) {
         row.dataset.status = statusInfo.text;
    }
}


function updateAssessmentRow(tableRow, score, totalPoints) {
    if (!tableRow) return;

    // Find percentage and status cells
    const percentageCell = tableRow.querySelector('.percentage-cell');
    const statusCell = tableRow.querySelector('.status-cell');

    let percentage = null;
    let statusInfo = getStatusInfoFromGrade(null); // Default to N/A
    let percentageHtml = '<span class="text-gray-400 text-sm">-</span>'; // Default display for percentage

    // Calculate percentage if score is valid and totalPoints is positive
    const maxPoints = (typeof totalPoints === 'number' && totalPoints > 0) ? totalPoints : null;
    if (score !== null && maxPoints) {
        percentage = Math.round((score / maxPoints) * 100);
        const statusBasedOnPercent = getStatusInfoFromGrade(percentage); // Status based on percentage
        // Determine color class for the percentage text itself
        const percentageColorClass = percentage >= 90 ? 'text-green-600' :
                                   percentage >= 70 ? 'text-blue-600' :
                                   percentage >= 60 ? 'text-yellow-600' : 'text-red-600';
        percentageHtml = `<span class="font-medium text-sm ${percentageColorClass}">${percentage}%</span>`;
        statusInfo = statusBasedOnPercent; // Use status derived from percentage
    }

    // Update Percentage Cell
    if (percentageCell) {
        percentageCell.innerHTML = percentageHtml;
    }

    // Update Status Cell
    if (statusCell) {
        // Show status badge if scored, otherwise show 'Not Graded' text
        statusCell.innerHTML = (score !== null) ?
            `<span class="px-2.5 py-0.5 inline-flex text-xs leading-5 font-semibold rounded-full status-badge ${statusInfo.classes}">${statusInfo.text}</span>` :
            '<span class="text-xs text-gray-400">Not Graded</span>';
    }
}


// --- Page-Specific Features ---
function initializePageSpecificFeatures() {
    // Initialize input focus/blur/enter behavior globally for relevant inputs
    document.querySelectorAll('.grade-input, .score-input').forEach(input => {
        // On focus: select text, clear validation styles
        input.addEventListener('focus', function() {
            this.select();
            this.classList.remove('border-green-500', 'border-red-500', 'border-yellow-500', 'bg-green-50/50', 'animate-pulse');
        });
        // On Enter key: blur the input (which often triggers the change event implicitly)
        input.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault(); // Prevent form submission if inside a form
                this.blur();
            }
        });
    });

    // --- Page-specific initializations based on URL or unique element IDs ---
    const currentPath = window.location.pathname;

    if (document.getElementById('gradeDistributionChart')) {
        // initializeDashboardCharts(); // Assumed to be in dashboard.html <script>
        console.log("Initializing dashboard features...");
    }
    else if (currentPath.startsWith('/class/')) {
        // initializeClassPage(); // Assumed to be in class_view.html <script>
        console.log("Initializing class view features...");
    }
    else if (document.getElementById('searchAssignments')) {
        initializeAssignmentsPageFilters(); // For assignments.html
        console.log("Initializing assignments page features...");
    }
    else if (document.getElementById('searchInput')) { // Main search on students.html
        initializeStudentPageFilters(); // For students.html
        console.log("Initializing all students page features...");
    }

    // Always initialize class management modals (as they are in base.html)
    initializeClassManagement();
}


// Specific function for student page filters (students.html)
function initializeStudentPageFilters() {
    const searchInput = document.getElementById('searchInput'); // Main search on students page
    const statusFilter = document.getElementById('statusFilter');
    const classFilter = document.getElementById('classFilterStudents'); // Specific ID for this page
    const sectionFilter = document.getElementById('sectionFilter');
    const studentTableBody = document.getElementById('studentTableBody');

    if (!studentTableBody) {
        // console.warn("Student table body not found. Skipping student page filters.");
        return;
    }
    
    // Check for other filter elements
    if (!searchInput || !statusFilter || !classFilter || !sectionFilter) {
         console.warn("Student page filter elements not all found.");
         // We can still proceed if only some filters are missing, but log it
    }
    
    const studentRows = Array.from(studentTableBody.querySelectorAll('.student-row'));

    function filterStudents() {
        const searchTerm = searchInput ? searchInput.value.toLowerCase().trim() : '';
        const statusValue = statusFilter ? statusFilter.value : 'all';
        const classValue = classFilter ? classFilter.value : 'all';
        const sectionValue = sectionFilter ? sectionFilter.value : 'all';
        let visibleCount = 0;

        studentRows.forEach(row => {
            // Read data attributes once
            const name = row.dataset.name?.toLowerCase() || '';
            const email = row.dataset.email?.toLowerCase() || '';
            const uid = row.dataset.uid?.toLowerCase() || '';
            const status = row.dataset.status || 'N/A'; // Match status from row data
            const classId = row.dataset.classId || '';
            const section = row.dataset.section || ''; // Assuming data-section exists

            const matchesSearch = searchTerm === '' ||
                                  name.includes(searchTerm) ||
                                  email.includes(searchTerm) ||
                                  uid.includes(searchTerm);
            const matchesStatus = statusValue === 'all' || status === statusValue;
            const matchesClass = classValue === 'all' || classId === classValue;
            const matchesSection = sectionValue === 'all' || section.toLowerCase() === sectionValue.toLowerCase();

            const isVisible = matchesSearch && matchesStatus && matchesClass && matchesSection;
            row.style.display = isVisible ? '' : 'none'; // Use '' for default display (table-row)
            if (isVisible) visibleCount++;
        });

        // Toggle the "No students found" message row
        const noStudentsRow = studentTableBody.querySelector('.no-students-row'); // Add class 'no-students-row' to the message row in HTML
        if (noStudentsRow) {
            noStudentsRow.style.display = (visibleCount === 0) ? '' : 'none';
        }

        // Update bulk actions based on visible rows
        if (typeof updateBulkActionsVisibility === 'function') {
            updateBulkActionsVisibility();
        }
    }

    // Attach filter event listeners with debouncing for search
    if(searchInput) searchInput.addEventListener('input', debounce(filterStudents, 300));
    if(statusFilter) statusFilter.addEventListener('change', filterStudents);
    if(classFilter) classFilter.addEventListener('change', filterStudents);
    if(sectionFilter) sectionFilter.addEventListener('change', filterStudents);

    // Initial filter on page load
    filterStudents();
}


// Specific function for assignments page filters (assignments.html)
function initializeAssignmentsPageFilters() {
    const searchInput = document.getElementById('searchAssignments');
    const classFilter = document.getElementById('classFilter'); // Assuming ID from assignments.html
    const typeFilter = document.getElementById('typeFilter'); // Assuming ID from assignments.html
    const assignmentsGrid = document.querySelector('.assignments-grid'); // Target the grid

    if (!assignmentsGrid) {
        // console.warn("Assignment grid not found. Skipping assignment filters.");
        return;
    }

    // *** FIX: Load the class checkboxes on page load ***
    // Find the class list in the modal and populate it
    const checkboxList = document.getElementById('assignmentClassList');
    if(checkboxList) {
        // Don't await, let it load in the background
        refreshAssignmentClassCheckboxes(checkboxList);
    } else {
        console.warn("Could not find #assignmentClassList to populate.");
    }
    // *** END FIX ***
    
    if (!searchInput && !classFilter && !typeFilter) {
         console.warn("Assignment filter elements not found.");
         // We can still proceed if only some filters are missing
    }
    
    const assignmentCards = Array.from(assignmentsGrid.querySelectorAll('.assignment-card')); // Target cards

    function filterAssignments() {
        const searchTerm = searchInput ? searchInput.value.toLowerCase().trim() : '';
        const classValue = classFilter ? classFilter.value : 'all';
        const typeValue = typeFilter ? typeFilter.value : 'all';
        let visibleCount = 0;

        assignmentCards.forEach(card => {
            const title = card.dataset.title?.toLowerCase() || ''; // Use data attributes set in HTML
            const classId = card.dataset.classId || '';
            const type = card.dataset.type?.toLowerCase() || '';
            const className = card.dataset.className?.toLowerCase() || ''; // Added class name search

            const matchesSearch = searchTerm === '' || title.includes(searchTerm) || className.includes(searchTerm);
            const matchesClass = classValue === 'all' || classId === classValue;
            const matchesType = typeValue === 'all' || type === typeValue;

            const isVisible = matchesSearch && matchesClass && matchesType;
            card.style.display = isVisible ? '' : 'none'; // Use '' for default display (grid item)
            if (isVisible) visibleCount++;
        });

        // Toggle the "No assignments found" message
        const emptyState = assignmentsGrid.querySelector('div:not(.assignment-card)');
        if (emptyState) {
            emptyState.style.display = (visibleCount === 0) ? '' : 'none';
        }
    }

    // Attach listeners
    if (searchInput) searchInput.addEventListener('input', debounce(filterAssignments, 300));
    if (classFilter) classFilter.addEventListener('change', filterAssignments);
    if (typeFilter) typeFilter.addEventListener('change', filterAssignments);

    // Initial filter
    filterAssignments();
}


// --- Modal Functions (Generic show/close + specific ones) ---

// Generic function to close any modal by ID
function closeModal(modalId) {
    const modal = document.getElementById(modalId);
    if (!modal) return;

    modal.classList.add('opacity-0');
    // Find the dialog element more reliably
    const dialog = modal.querySelector('.bg-white.rounded-xl') || modal.children[0]; // Common patterns
    if (dialog) dialog.classList.add('scale-95', 'opacity-0');

    // Wait for animation to finish before hiding and resetting form
    setTimeout(() => {
        modal.classList.add('hidden');
        const form = modal.querySelector('form');
        if (form) {
            form.reset();
            // Clear specific error messages
             const errorMessages = form.querySelectorAll('[id$="Error"], .form-error'); // Common error patterns
             errorMessages.forEach(el => { el.textContent = ''; el.classList.add('hidden'); });
        }
        // Reset any specific state related to the modal
        if(modalId === 'addAssignmentModal') deselectAllClasses(); // Reset class selection
        if(modalId === 'importStudentsModal') { // Reset import modal display
             const fileNameSpan = document.getElementById('csvFileName');
             if (fileNameSpan) {
                 fileNameSpan.textContent = 'No file chosen';
                 fileNameSpan.classList.add('text-gray-400');
                 fileNameSpan.classList.remove('text-gray-700');
             }
             const fileInput = document.getElementById('student_csv');
             if(fileInput) fileInput.value = ''; // Clear file input
        }
    }, 300); // Match transition duration
}


// Generic function to show any modal by ID
function showModal(modalId) {
    const modal = document.getElementById(modalId);
    // Find the dialog element more reliably
    const dialog = modal ? (modal.querySelector('.bg-white.rounded-xl') || modal.children[0]) : null;

    if (!modal || !dialog) {
        console.error(`Modal elements not found for ID: ${modalId}`);
        showToast('Error: Could not open modal.', 'error');
        return;
    }

    // Ensure form is reset before showing
    const form = modal.querySelector('form');
    if (form) form.reset();


    modal.classList.remove('hidden');
    // Use requestAnimationFrame for smoother animation start
    requestAnimationFrame(() => {
        modal.classList.remove('opacity-0');
        dialog.classList.remove('scale-95', 'opacity-0');
    });
}


// Assignment Modals
function showAddAssignmentModal() {
    // Optionally refresh class checkboxes if classes can change frequently
    // This is now handled on page load by initializeAssignmentsPageFilters
    // and after class CUD by refreshAllClassSelects

    const dueDateInput = document.getElementById('assignmentDueDate');
    if (dueDateInput) {
        try {
            const tomorrow = new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);
            // Format as YYYY-MM-DD for the input
            dueDateInput.value = tomorrow.toISOString().split('T')[0];
        } catch(e) { console.error("Could not set default date", e); }
    }
    deselectAllClasses(); // Ensure checkboxes are cleared
    showModal('addAssignmentModal');
}

function closeAddAssignmentModal() {
    closeModal('addAssignmentModal');
}


// Student Modals
async function showAddStudentModal() {
    // Refresh class dropdown options dynamically *before* showing
    const studentClassSelect = document.getElementById('addStudentClass'); // Correct ID for Add modal
    if (studentClassSelect) {
        await refreshSelectWithOptions(studentClassSelect, '/api/get_classes', 'Error loading classes');
    } else {
        console.warn("Could not find or refresh class dropdown in Add Student modal.");
    }
    showModal('addStudentModal');
}

function closeAddStudentModal() {
    closeModal('addStudentModal');
}

// Helper to refresh a <select> element with options from an API
async function refreshSelectWithOptions(selectElement, apiUrl, errorMessage = 'Error loading options', loadingElementId = null) {
    if (!selectElement) {
        console.error("Target select element not provided for refresh.");
        return;
    }
    const loadingSpinner = loadingElementId ? document.getElementById(loadingElementId) : null;
    const previouslySelectedValue = selectElement.value; // Store current value if needed

    selectElement.disabled = true;
    if (loadingSpinner) loadingSpinner.classList.remove('hidden');
    selectElement.innerHTML = '<option value="" disabled selected>Loading...</option>'; // Loading state

    try {
        const optionsData = await fetchWithErrorHandling(apiUrl + '?nocache=' + new Date().getTime()); // Add cache buster
        if (!Array.isArray(optionsData)) throw new Error('Invalid data format received');

        selectElement.innerHTML = '<option value="" disabled>-- Select a class --</option>'; // Reset with prompt

        // Assuming optionsData is an array of objects like {id: 'c1', name: 'Grade 6', section: 'Tata'}
        optionsData
            .sort((a, b) => { // Sort options alphabetically
                const textA = (a.name && a.section) ? `${a.name} - ${a.section}` : a;
                const textB = (b.name && b.section) ? `${b.name} - ${b.section}` : b;
                return textA.localeCompare(textB);
            })
            .forEach(item => {
                const option = document.createElement('option');
                if (typeof item === 'object' && item.id && item.name && item.section) {
                    option.value = item.id;
                    option.textContent = `${item.name} - ${item.section}`;
                } else { // Fallback for simple string arrays
                    option.value = item;
                    option.textContent = item;
                }
                selectElement.appendChild(option);
            });

        // Try to re-select the previous value if it still exists
        if (previouslySelectedValue && selectElement.querySelector(`option[value="${previouslySelectedValue}"]`)) {
            selectElement.value = previouslySelectedValue;
        } else {
             selectElement.value = ""; // Default to the prompt
        }

    } catch (error) {
        console.error(`Error refreshing select ${selectElement.id}:`, error);
        showToast(errorMessage, 'error');
        selectElement.innerHTML = `<option value="" disabled selected>Error loading</option>`; // Error state
    } finally {
        selectElement.disabled = false;
        if (loadingSpinner) loadingSpinner.classList.add('hidden');
    }
}

// Import Students Modal
function showImportStudentsModal() {
    showModal('importStudentsModal');
}

function closeImportStudentsModal() {
    closeModal('importStudentsModal');
}

// Edit Student Modal
async function showEditStudentModal(studentId) {
    const modal = document.getElementById('editStudentModal');
    const dialog = document.getElementById('editStudentDialog');
    const form = document.getElementById('editStudentForm');

    if (!modal || !dialog || !form) {
        console.error("Edit Student modal elements not found!");
        showToast('Error: Modal elements missing.', 'error');
        return;
    }

    form.reset(); // Reset form fields
    form.dataset.studentId = ''; // Clear previous student ID
    document.getElementById('editStudentModalTitle').textContent = 'Loading Student...';

    // Hide any previous error messages
    document.getElementById('uidDuplicateError')?.classList.add('hidden');
    document.getElementById('rollNumberDuplicateError')?.classList.add('hidden');

    // Reset skill sliders (if they exist on the page)
    document.querySelectorAll('.skill-slider').forEach(slider => {
        slider.value = 1; // Default to 1
        const valueId = `skillValue-${slider.dataset.skillName.replace(/[\s&]/g, '_')}`; // Safer replace
        const valueSpan = document.getElementById(valueId);
        if (valueSpan) valueSpan.textContent = '1';
    });
    
    // Refresh class dropdown *before* showing
    const classSelect = document.getElementById('editStudentClass');
    if (classSelect) {
        await refreshSelectWithOptions(classSelect, '/api/get_classes', 'Error loading classes');
    }

    // Show modal
    showModal('editStudentModal');

    // Fetch student data and populate form
    try {
        const student = await fetchWithErrorHandling(`/get_student_details?student_id=${studentId}`);
        if (student.error) throw new Error(student.error); // Handle cases where server returns {error: ...}
        
        form.dataset.studentId = student.id;
        document.getElementById('editStudentModalTitle').textContent = `Edit ${student.name}`;
        
        // Populate standard fields
        document.getElementById('editStudentName').value = student.name || '';
        document.getElementById('editStudentEmail').value = student.email || '';
        document.getElementById('editStudentClass').value = student.classId || '';
        document.getElementById('editStudentUid').value = student.uid || '';
        document.getElementById('editStudentRollNumber').value = student.rollNumber || '';
        document.getElementById('editStudentParentPhone').value = student.parentPhone || '';

        // Populate Skill Sliders (only if they exist on the current page)
        if (student.skills && typeof student.skills === 'object') {
            for (const skillName in student.skills) {
                const rating = student.skills[skillName] || 0;
                const inputId = `skillRating-${skillName.replace(/[\s&]/g, '_')}`;
                const valueId = `skillValue-${skillName.replace(/[\s&]/g, '_')}`;

                const slider = document.getElementById(inputId);
                const valueSpan = document.getElementById(valueId);

                if (slider) slider.value = rating;
                if (valueSpan) valueSpan.textContent = rating;
            }
        }

    } catch (error) {
        console.error('Error fetching student details for edit:', error);
        showToast(`Error loading data: ${error.message}`, 'error');
        closeEditStudentModal(); // Close modal on failure
    }
}

function closeEditStudentModal() {
    closeModal('editStudentModal');
}

// Student Detail Modal (from students.html)
async function viewStudentDetails(studentId) {
    const modal = document.getElementById('studentModal');
    const modalContent = document.getElementById('modalContent');
    const modalTitle = document.getElementById('modalStudentName');
    
    if (!modal || !modalContent || !modalTitle) {
        console.error("Student detail modal elements not found.");
        showToast('Error: Modal elements missing.', 'error');
        return;
    }

    modalTitle.textContent = 'Loading...';
    modalContent.innerHTML = '<div class="text-center p-8"><i class="fas fa-spinner fa-spin text-2xl text-gray-500"></i></div>';
    
    showModal('studentModal');

    try {
        const student = await fetchWithErrorHandling(`/get_student_details?student_id=${studentId}`);
        if (student.error) throw new Error(student.error); // Handle server error response
        
        modalTitle.textContent = student.name;
        const statusInfo = getStatusInfoFromGrade(student.overallGrade);
        
        // --- UPDATED: Display Skills in Modal ---
        let skillsHtml = '<span class="text-xs text-gray-500">No skills data available.</span>';
        if (student.skills && typeof student.skills === 'object' && Object.keys(student.skills).length > 0) {
             skillsHtml = Object.entries(student.skills).map(([skillName, rating]) => {
                let stars = '';
                for(let i = 1; i <= 5; i++) {
                    stars += `<i class="fa-star ${i <= rating ? 'fas text-yellow-400' : 'far text-gray-300'}"></i>`;
                }
                return `<div class="flex justify-between items-center text-xs py-1">
                            <span class="text-gray-700">${skillName}</span>
                            <span class="flex space-x-0.5">${stars}</span>
                        </div>`;
            }).join('');
        }
        // --- END UPDATE ---

        modalContent.innerHTML = `
            <div class="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4">
                <div class="border-b pb-2">
                    <label class="block text-xs font-medium text-gray-500 uppercase tracking-wider">Email</label>
                    <p class="mt-1 text-sm text-gray-800">${student.email || '-'}</p>
                </div>
                <div class="border-b pb-2">
                    <label class="block text-xs font-medium text-gray-500 uppercase tracking-wider">Class</label>
                    <p class="mt-1 text-sm text-gray-800">${student.className || 'N/A'}</p>
                </div>
                <div class="border-b pb-2">
                    <label class="block text-xs font-medium text-gray-500 uppercase tracking-wider">UID</label>
                    <p class="mt-1 text-sm text-gray-800">${student.uid || '-'}</p>
                </div>
                <div class="border-b pb-2">
                    <label class="block text-xs font-medium text-gray-500 uppercase tracking-wider">Roll No</label>
                    <p class="mt-1 text-sm text-gray-800">${student.rollNumber || '-'}</p>
                </div>
                <div class="border-b pb-2">
                    <label class="block text-xs font-medium text-gray-500 uppercase tracking-wider">Overall Grade</label>
                    <p class="mt-1 text-lg font-semibold ${statusInfo.classes.replace('bg-', 'text-').split(' ')[0]}">${student.overallGrade}%</p>
                </div>
                <div class="border-b pb-2">
                    <label class="block text-xs font-medium text-gray-500 uppercase tracking-wider">Status</label>
                    <span class="mt-1 inline-block px-2.5 py-0.5 rounded-full text-xs font-semibold ${statusInfo.classes}">${statusInfo.text}</span>
                </div>
                <div class="border-b pb-2 md:col-span-2">
                    <label class="block text-xs font-medium text-gray-500 uppercase tracking-wider">Last Milestone</label>
                    <p class="mt-1 text-sm text-gray-800">${student.lastMilestone || '-'}</p>
                </div>
                <div class="pb-2 md:col-span-2">
                    <label class="block text-xs font-medium text-gray-500 uppercase tracking-wider mb-2">Skills</label>
                    <div class="space-y-1">
                        ${skillsHtml}
                    </div>
                </div>
            </div>`;
    } catch (error) {
        console.error('Error loading student details:', error);
        modalContent.innerHTML = `<div class="text-center p-8 text-red-600"><i class="fas fa-exclamation-triangle mr-2"></i>Error loading details.</div>`;
        showToast('Error loading student details.', 'error');
    }
}


// Class Management Modals
async function showManageClassesModal() {
    const classesList = document.getElementById('classes-list');
    if (!classesList) {
        console.error("Manage Classes modal list area not found.");
        return;
    }

    classesList.innerHTML = '<p class="p-4 text-center text-gray-500 text-sm">Loading classes...</p>';
    showModal('manage-classes-modal');

    try {
        const classes = await fetchWithErrorHandling('/api/get_classes');
        
        if (Array.isArray(classes) && classes.length > 0) {
            classes.sort((a,b) => `${a.name} - ${a.section}`.localeCompare(`${b.name} - ${b.section}`)); // Sort classes
            
            classesList.innerHTML = ''; // Clear loading
            classes.forEach(cls => {
                if (!cls.id || !cls.name || !cls.section) return;
                
                const div = document.createElement('div');
                div.className = 'flex flex-col sm:flex-row justify-between sm:items-center p-3 border rounded-lg bg-gray-50/50';
                div.innerHTML = `
                    <div class="mb-2 sm:mb-0">
                        <span class="font-medium text-gray-800">${cls.name} - ${cls.section}</span>
                        <span class="text-sm text-gray-500 block sm:inline sm:ml-2">(${cls.campus || 'N/A'}, Students: ${cls.studentCount || 0})</span>
                    </div>
                    <div class="flex-shrink-0 space-x-2">
                        <button onclick="showEditClassModal('${cls.id}')" class="bg-yellow-100 text-yellow-800 px-3 py-1 rounded hover:bg-yellow-200 text-xs font-medium">Edit</button>
                        <button onclick="deleteClass('${cls.id}')" class="bg-red-100 text-red-800 px-3 py-1 rounded hover:bg-red-200 ml-2 text-xs font-medium">Delete</button>
                    </div>
                `;
                classesList.appendChild(div);
            });
        } else {
            classesList.innerHTML = '<p class="p-4 text-center text-gray-500 text-sm">No classes found. Add one to get started!</p>';
        }
    } catch (error) {
        console.error('Error fetching classes:', error);
        classesList.innerHTML = '<p class="p-4 text-center text-red-600 text-sm">Error loading classes.</p>';
        showToast('Failed to load classes.', 'error');
    }
}

function closeManageClassesModal() {
    closeModal('manage-classes-modal');
}

function showAddClassModal() {
    const form = document.getElementById('class-form');
    const title = document.getElementById('class-form-title');
    
    if (!form || !title) return;

    title.textContent = 'Add Class';
    form.reset(); // Clear form fields
    document.getElementById('class-id').value = ''; // Ensure ID is clear
    document.getElementById('class-form-error').classList.add('hidden'); // Hide error
    
    // Reset color picker
    document.getElementById('class-color').value = ''; // Clear hidden value
    document.querySelectorAll('input[name="color_option"]').forEach(radio => radio.checked = false);

    showModal('class-form-modal');
    
    // Set form submit handler for ADD action
    form.onsubmit = function(event) {
        event.preventDefault();
        addClass();
    };
}

async function showEditClassModal(classId) {
    const modal = document.getElementById('class-form-modal');
    const form = document.getElementById('class-form');
    const title = document.getElementById('class-form-title');
    const error = document.getElementById('class-form-error');
    
    if (!modal || !form || !title || !error) return;

    title.textContent = 'Loading Class...';
    form.reset();
    error.classList.add('hidden');
    showModal('class-form-modal'); // Show modal with loading state

    try {
        const data = await fetchWithErrorHandling(`/api/get_class/${classId}`);
        if (data.error) throw new Error(data.error); // Handle server-side error
        
        title.textContent = 'Edit Class';
        document.getElementById('class-id').value = data.id;
        document.getElementById('class-name').value = data.name || '';
        document.getElementById('class-section').value = data.section || '';
        document.getElementById('class-campus').value = data.campus || '';
        
        // Set color
        document.getElementById('class-color').value = data.color || '';
        const colorRadio = document.querySelector(`input[name="color_option"][value="${data.color}"]`);
        if (colorRadio) colorRadio.checked = true;

        // Set form submit handler for EDIT action
        form.onsubmit = function(event) {
            event.preventDefault();
            editClass(classId);
        };
        
    } catch (error) {
        console.error('Error fetching class:', error);
        error.textContent = 'Error loading class details.';
        error.classList.remove('hidden');
        showToast('Failed to load class details.', 'error');
        // Optionally close modal after a delay
        setTimeout(closeClassFormModal, 1500);
    }
}

function closeClassFormModal() {
    closeModal('class-form-modal');
}

// Reset Modal
function showResetConfirmation() {
    showModal('resetModal');
}

function hideResetConfirmation() {
    closeModal('resetModal');
}

// --- Modal Listeners ---
function initializeStudentModalListeners() {
    const modals = [
        { id: 'studentModal', closeFn: () => closeModal('studentModal') },
        { id: 'addStudentModal', closeFn: closeAddStudentModal },
        { id: 'editStudentModal', closeFn: closeEditStudentModal },
        { id: 'addAssignmentModal', closeFn: closeAddAssignmentModal },
        { id: 'importStudentsModal', closeFn: closeImportStudentsModal },
        { id: 'manage-classes-modal', closeFn: closeManageClassesModal },
        { id: 'class-form-modal', closeFn: closeClassFormModal },
        { id: 'resetModal', closeFn: hideResetConfirmation }
    ];

    modals.forEach(mInfo => {
        const modal = document.getElementById(mInfo.id);
        if (modal) {
            // Close on overlay click
            modal.addEventListener('click', function(e) {
                if (e.target === this) mInfo.closeFn();
            });
            // Find and attach close button listeners
            const closeButtons = modal.querySelectorAll('[onclick*="' + mInfo.closeFn.name + '"]');
             closeButtons.forEach(btn => {
                if(!btn.dataset.listenerAttached) {
                     btn.addEventListener('click', (e) => {
                        e.preventDefault(); // Prevent default if it's a button in a form
                        mInfo.closeFn();
                     });
                     btn.dataset.listenerAttached = true;
                }
             });
        }
    });

    // Close any open modal on Escape key
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            modals.forEach(mInfo => {
                const modal = document.getElementById(mInfo.id);
                if (modal && !modal.classList.contains('hidden')) {
                    mInfo.closeFn();
                }
            });
        }
    });
}

// --- Form Listeners ---
function initializeAssignmentFormListener() {
    const form = document.getElementById('addAssignmentForm');
    if (form) {
        form.addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const submitButton = form.querySelector('button[type="submit"]');
            const loadingSpinner = document.getElementById('addAssignmentLoading');
            const classSelectionError = document.getElementById('classSelectionError');
            
            // Get selected class IDs
            const selectedClasses = Array.from(document.querySelectorAll('.assignment-class-checkbox:checked'))
                .map(checkbox => checkbox.value);
            
            // Validate at least one class is selected
            if (selectedClasses.length === 0) {
                if (classSelectionError) {
                    classSelectionError.classList.remove('hidden');
                    classSelectionError.textContent = 'Please select at least one class.';
                }
                return;
            } else {
                if (classSelectionError) classSelectionError.classList.add('hidden');
            }
            
            const formData = new FormData(this);
            const assignmentData = {
                class_ids: selectedClasses,
                title: formData.get('title').trim(),
                due_date: formData.get('due_date'),
                total_points: parseInt(formData.get('total_points')),
                type: formData.get('type')
            };
            
            // Validate data
            if (!assignmentData.title || !assignmentData.due_date || !assignmentData.total_points || !assignmentData.type) {
                showToast('Please fill out all required fields.', 'error');
                return;
            }
            
            if (assignmentData.total_points <= 0) {
                showToast('Total points must be greater than 0.', 'error');
                return;
            }
            
            const originalButtonHTML = submitButton.innerHTML;
            setLoadingState(submitButton, true, originalButtonHTML);
            
            try {
                const result = await fetchWithErrorHandling('/add_assignment', {
                    method: 'POST',
                    body: JSON.stringify(assignmentData)
                });
                
                if (result.success) {
                    closeAddAssignmentModal();
                    showToast(result.message || `Assignment created for ${selectedClasses.length} class(es)!`, 'success');
                    setTimeout(() => location.reload(), 1000); // Reload to show new assignment
                } else {
                    throw new Error(result.message || 'Failed to create assignment.');
                }
            } catch (error) {
                console.error('Error creating assignment:', error);
                showToast(`Error: ${error.message}`, 'error');
            } finally {
                setLoadingState(submitButton, false, originalButtonHTML);
            }
        });
    }
}

function initializeAddStudentFormListener() {
    const form = document.getElementById('addStudentForm');
    if (form) {
        form.addEventListener('submit', async (e) => {
            e.preventDefault();
            const submitButton = form.querySelector('button[type="submit"]');
            const originalButtonHTML = submitButton.innerHTML;
            setLoadingState(submitButton, true, originalButtonHTML);

            const formData = new FormData(form);
            const data = {
                name: formData.get('name'),
                email: formData.get('email'),
                classId: formData.get('classId'), // Changed from class_id
                uid: formData.get('uid'),
                rollNumber: formData.get('rollNumber'),
                parentPhone: formData.get('parentPhone'), // Changed from parent_phone
            };
            
            try {
                const result = await fetchWithErrorHandling('/add_student', {
                    method: 'POST',
                    body: JSON.stringify(data)
                });
                
                if (result.success) {
                    showToast('Student added successfully!', 'success');
                    closeAddStudentModal();
                    setTimeout(() => window.location.reload(), 1000); // Reload to see new student
                } else {
                    throw new Error(result.message || 'Failed to add student.');
                }
            } catch (error) {
                showToast(`Error: ${error.message}`, 'error');
            } finally {
                setLoadingState(submitButton, false, originalButtonHTML);
            }
        });
    }
}

// Handles form submission for editing a student (from students.html or student_profile.html)
function initializeEditStudentFormListener() {
    const form = document.getElementById('editStudentForm');
    if (form) {
        form.addEventListener('submit', async function(e) {
            e.preventDefault();
            const studentId = form.dataset.studentId;
            if (!studentId) {
                showToast('Error: Student ID is missing.', 'error');
                return;
            }

            const submitButton = form.querySelector('button[type="submit"]');
            const loadingSpinner = document.getElementById('editStudentLoading'); // Specific spinner
            const originalButtonHTML = submitButton.innerHTML;
            
            if(submitButton) submitButton.disabled = true;
            if(loadingSpinner) loadingSpinner.classList.remove('hidden');
            // Or use generic setLoadingState
            // setLoadingState(submitButton, true, originalButtonHTML);

            const formData = new FormData(form);

            // Collect Skill Ratings (if sliders exist on the page)
            const skillsData = {};
            document.querySelectorAll('.skill-slider').forEach(slider => {
                const skillName = slider.dataset.skillName; 
                if(skillName) {
                    skillsData[skillName] = parseInt(slider.value, 10);
                }
            });

            const updatedData = {
                name: formData.get('name'),
                email: formData.get('email'),
                classId: formData.get('classId'),
                uid: formData.get('uid'),
                rollNumber: formData.get('rollNumber'),
                parentPhone: formData.get('parentPhone') || '',
                skills: skillsData // Pass the collected skills dictionary
            };
            
            // If no skill sliders were found, don't send an empty 'skills' object
            // This prevents overwriting existing skills if the edit form doesn't show them
            if (Object.keys(skillsData).length === 0) {
                delete updatedData.skills;
            }

            // Validate required fields
            if (!updatedData.name || !updatedData.email || !updatedData.classId || !updatedData.uid || !updatedData.rollNumber) {
                showToast('Name, Email, Class, UID, and Roll Number are required.', 'error');
                if(submitButton) submitButton.disabled = false;
                if(loadingSpinner) loadingSpinner.classList.add('hidden');
                // setLoadingState(submitButton, false, originalButtonHTML);
                return;
            }

            // Check for duplicates
            try {
                const duplicateCheck = await validateUniqueFields(studentId, updatedData.uid, updatedData.rollNumber);
                
                const uidErrorEl = document.getElementById('uidDuplicateError');
                const rollErrorEl = document.getElementById('rollNumberDuplicateError');
                let hasErrors = false;

                if (duplicateCheck.duplicate_uid) {
                    if(uidErrorEl) {
                         uidErrorEl.textContent = `UID used by ${duplicateCheck.duplicate_uid}`;
                         uidErrorEl.classList.remove('hidden');
                    }
                    hasErrors = true;
                } else if(uidErrorEl) {
                    uidErrorEl.classList.add('hidden');
                }
                
                if (duplicateCheck.duplicate_roll) {
                     if(rollErrorEl) {
                         rollErrorEl.textContent = `Roll No used by ${duplicateCheck.duplicate_roll}`;
                         rollErrorEl.classList.remove('hidden');
                    }
                    hasErrors = true;
                } else if(rollErrorEl) {
                    rollErrorEl.classList.add('hidden');
                }

                if(hasErrors) {
                    showToast('UID or Roll Number is already in use.', 'error');
                    throw new Error('Duplicate fields found.'); // Stop execution
                }

                // If no duplicates, proceed with update
                const result = await fetchWithErrorHandling(`/edit_student/${studentId}`, {
                    method: 'POST',
                    body: JSON.stringify(updatedData)
                });
                
                if (result.success) {
                    closeEditStudentModal();
                    showToast('Student details updated successfully!', 'success');
                    setTimeout(() => location.reload(), 500); // Reload page
                } else {
                    throw new Error(result.message || 'Failed to update student.');
                }
            } catch (error) {
                console.error('Error updating student:', error);
                if (error.message !== 'Duplicate fields found.') { // Don't double-toast
                    showToast(`Error: ${error.message}`, 'error');
                }
            } finally {
                // Re-enable button
                if(submitButton) submitButton.disabled = false;
                if(loadingSpinner) loadingSpinner.classList.add('hidden');
                // setLoadingState(submitButton, false, originalButtonHTML);
            }
        });
    }
}


function initializeImportStudentsFormListener() {
    const form = document.getElementById('importStudentsForm');
    if (form) {
        const fileInput = document.getElementById('student_csv');
        const fileNameSpan = document.getElementById('csvFileName');
        const submitButton = form.querySelector('button[type="submit"]');

        // Show file name on selection
        if(fileInput && fileNameSpan) {
            fileInput.addEventListener('change', () => {
                if (fileInput.files.length > 0) {
                    fileNameSpan.textContent = fileInput.files[0].name;
                    fileNameSpan.classList.remove('text-gray-400');
                    fileNameSpan.classList.add('text-gray-700');
                } else {
                    fileNameSpan.textContent = 'No file chosen';
                    fileNameSpan.classList.add('text-gray-400');
                    fileNameSpan.classList.remove('text-gray-700');
                }
            });
        }

        form.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            if (!fileInput || !fileInput.files || fileInput.files.length === 0) {
                showToast('Please select a CSV file to upload.', 'error');
                return;
            }
            
            const formData = new FormData(form);
            const originalButtonHTML = submitButton.innerHTML;
            setLoadingState(submitButton, true, originalButtonHTML);

            try {
                // Use fetchWithErrorHandling for file upload
                const result = await fetchWithErrorHandling('/upload_students_csv', {
                    method: 'POST',
                    body: formData // Pass FormData directly
                    // 'Content-Type' is intentionally omitted
                });
                
                if (result.success) {
                    showToast(result.message || 'Students imported successfully!', 'success');
                    if(result.errors && result.errors.length > 0) {
                         // Show a follow-up toast with error summary
                        setTimeout(() => {
                           showToast(`Import finished with ${result.errors.length} errors.`, 'info');
                        }, 4000);
                        // TODO: Optionally display errors in the modal
                    }
                    closeImportStudentsModal();
                    setTimeout(() => window.location.reload(), 1500); // Reload page
                } else {
                    // Show error message from server
                    throw new Error(result.message || 'Failed to import students.');
                }
            } catch (error) {
                console.error('Error uploading file:', error);
                showToast(`Error: ${error.message}`, 'error');
            } finally {
                // ALWAYS re-enable the button
                setLoadingState(submitButton, false, originalButtonHTML);
            }
        });
    }
}


function initializeResetModalListeners() {
    const modal = document.getElementById('resetModal');
    if (modal) {
        const confirmButton = document.getElementById('confirmReset');
        if(confirmButton) {
            confirmButton.addEventListener('click', async () => {
                await resetAllData();
            });
        }
    }
}

// --- Class Management Functions ---
function initializeClassManagement() {
    // Attach listener to the main "Manage Classes" button (if it exists)
    const manageClassesButton = document.getElementById('manageClassesButton');
    if (manageClassesButton) {
        manageClassesButton.addEventListener('click', showManageClassesModal);
    }
    
    // Attach listener to the "Add New Class" button *inside* the manage modal
    const addClassButton = document.getElementById('add-class-btn');
    if (addClassButton) {
        addClassButton.addEventListener('click', showAddClassModal);
    }
    
    // Attach listener to the color picker radios
    const colorPickerRadios = document.querySelectorAll('input[name="color_option"]');
    colorPickerRadios.forEach(radio => {
        radio.addEventListener('change', () => {
             const targetInput = document.getElementById(radio.dataset.colorTarget);
             if (targetInput) {
                targetInput.value = radio.value;
             }
        });
    });
}


async function addClass() {
    const form = document.getElementById('class-form');
    const submitButton = form.querySelector('button[type="submit"]');
    const errorEl = document.getElementById('class-form-error');
    const originalButtonHTML = submitButton.innerHTML;
    
    setLoadingState(submitButton, true, originalButtonHTML);
    errorEl.classList.add('hidden');

    const formData = new FormData(form);
    const data = {
        name: formData.get('name').trim(),
        section: formData.get('section').trim(),
        campus: formData.get('campus').trim(),
        color: formData.get('color') // Value from hidden input
    };
    
    if (!data.name || !data.section || !data.campus || !data.color) {
        errorEl.textContent = 'Please fill out all fields, including color.';
        errorEl.classList.remove('hidden');
        showToast('Please fill out all fields, including color.', 'error');
        setLoadingState(submitButton, false, originalButtonHTML);
        return;
    }

    try {
        const result = await fetchWithErrorHandling('/add_class', {
            method: 'POST',
            body: JSON.stringify(data)
        });
        
        if (result.success) {
            closeClassFormModal();
            await showManageClassesModal(); // Refresh the list
            showToast('Class added successfully!', 'success');
            // No full reload, just refresh dependent lists
            await refreshAllClassSelects();
        } else {
            throw new Error(result.message || 'Error adding class.');
        }
    } catch (error) {
        console.error('Error adding class:', error);
        errorEl.textContent = error.message;
        errorEl.classList.remove('hidden');
        showToast(error.message, 'error');
    } finally {
        setLoadingState(submitButton, false, originalButtonHTML);
    }
}

async function editClass(classId) {
    const form = document.getElementById('class-form');
    const submitButton = form.querySelector('button[type="submit"]');
    const errorEl = document.getElementById('class-form-error');
    const originalButtonHTML = submitButton.innerHTML;
    
    setLoadingState(submitButton, true, originalButtonHTML);
    errorEl.classList.add('hidden');
    
    const formData = new FormData(form);
    const data = {
        name: formData.get('name').trim(),
        section: formData.get('section').trim(),
        campus: formData.get('campus').trim(),
        color: formData.get('color') // Value from hidden input
    };
    
    if (!data.name || !data.section || !data.campus || !data.color) {
        errorEl.textContent = 'Please fill out all fields, including color.';
        errorEl.classList.remove('hidden');
        showToast('Please fill out all fields, including color.', 'error');
        setLoadingState(submitButton, false, originalButtonHTML);
        return;
    }

    try {
        const result = await fetchWithErrorHandling(`/edit_class/${classId}`, {
            method: 'POST',
            body: JSON.stringify(data)
        });
        
        if (result.success) {
            closeClassFormModal();
            await showManageClassesModal(); // Refresh the list
            showToast('Class updated successfully!', 'success');
            // No full reload, just refresh dependent lists
            await refreshAllClassSelects();
        } else {
            throw new Error(result.message || 'Error updating class.');
        }
    } catch (error) {
        console.error('Error updating class:', error);
        errorEl.textContent = error.message;
        errorEl.classList.remove('hidden');
        showToast(error.message, 'error');
    } finally {
        setLoadingState(submitButton, false, originalButtonHTML);
    }
}

async function deleteClass(classId) {
    // TODO: Replace with a custom modal confirmation
    if (!confirm(`Are you sure you want to delete this class? This action cannot be undone.`)) return;

    const button = document.querySelector(`button[onclick="deleteClass('${classId}')"]`);
    const originalButtonText = button ? button.innerHTML : 'Delete';
    
    if (button) setLoadingState(button, true, originalButtonText);

    try {
        const result = await fetchWithErrorHandling(`/delete_class/${classId}`, {
            method: 'POST'
        });
        
        if (result.success) {
            await showManageClassesModal(); // Refresh the list
            showToast('Class deleted successfully!', 'success');
             // No full reload, just refresh dependent lists
            await refreshAllClassSelects();
        } else {
             throw new Error(result.message || 'Error deleting class.');
        }
    } catch (error) {
        console.error('Error deleting class:', error);
        showToast(error.message, 'error');
    } finally {
         // Button might be gone, so check
        if (button) setLoadingState(button, false, originalButtonText);
    }
}

// Helper to refresh all class <select> dropdowns on the page after CUD operations
async function refreshAllClassSelects() {
    const selectsToRefresh = [
        document.getElementById('classFilter'),           // Assignments Page
        document.getElementById('classFilterStudents'),   // Students Page
        document.getElementById('addStudentClass'),       // Add Student Modal
        document.getElementById('editStudentClass'),      // Edit Student Modal
        document.getElementById('class_id')               // Gradebook Page
    ];
    
    for (const selectEl of selectsToRefresh) {
        if (selectEl) {
            await refreshSelectWithOptions(selectEl, '/api/get_classes', 'Error refreshing class list');
        }
    }
    
    // Also refresh the checkbox list in the Add Assignment modal
    const checkboxList = document.getElementById('assignmentClassList');
    if(checkboxList) {
        await refreshAssignmentClassCheckboxes(checkboxList);
    }
}

async function refreshAssignmentClassCheckboxes(listElement) {
     if (!listElement) return;
     listElement.innerHTML = '<p class="text-sm text-gray-500">Loading classes...</p>';
     
     try {
        const classes = await fetchWithErrorHandling('/api/get_classes' + '?nocache=' + new Date().getTime()); // Add cache buster
        if (Array.isArray(classes) && classes.length > 0) {
            listElement.innerHTML = ''; // Clear loading
            classes
                .sort((a,b) => `${a.name} - ${a.section}`.localeCompare(`${b.name} - ${b.section}`))
                .forEach(cls => {
                    const label = document.createElement('label');
                    label.htmlFor = `class-check-${cls.id}`;
                    label.className = "flex items-center p-2 rounded-md hover:bg-gray-100 transition-colors cursor-pointer";
                    label.innerHTML = `
                        <input type="checkbox" id="class-check-${cls.id}" value="${cls.id}" class="assignment-class-checkbox h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                        <span class="ml-3 text-sm text-gray-700">${cls.name} - ${cls.section}</span>
                    `;
                    listElement.appendChild(label);
                });
        } else {
             listElement.innerHTML = '<p class="text-sm text-gray-500">No classes found. Please add a class first.</p>';
        }
     } catch (error) {
         console.error("Error refreshing assignment class list:", error);
         listElement.innerHTML = '<p class="text-sm text-red-500">Error loading classes.</p>';
     }
}


// --- Bulk Student Actions ---
function initializeBulkStudentActions() {
    const bulkActionContainer = document.getElementById('bulkActionContainer');
    const bulkDeleteButton = document.getElementById('bulkDeleteButton');
    const selectAllCheckbox = document.getElementById('selectAllStudents');
    const studentTableBody = document.getElementById('studentTableBody');
    
    if (!bulkActionContainer || !bulkDeleteButton || !selectAllCheckbox || !studentTableBody) {
        // console.warn("Bulk action elements not found. Skipping.");
        return;
    }
    const studentCheckboxes = studentTableBody.querySelectorAll('.student-checkbox');

    const updateBulkActions = () => {
        // Only count visible checkboxes
        const visibleCheckboxes = Array.from(studentCheckboxes).filter(cb => cb.closest('tr').style.display !== 'none');
        const checkedCount = visibleCheckboxes.filter(cb => cb.checked).length;
        
        bulkActionContainer.classList.toggle('hidden', checkedCount === 0);
        if(document.getElementById('selectedCount')) {
             document.getElementById('selectedCount').textContent = `${checkedCount} student${checkedCount !== 1 ? 's' : ''} selected`;
        }
        
        // Update "Select All" state
        selectAllCheckbox.checked = visibleCheckboxes.length > 0 && checkedCount === visibleCheckboxes.length;
        // Set indeterminate state
        selectAllCheckbox.indeterminate = checkedCount > 0 && checkedCount < visibleCheckboxes.length;
    };

    selectAllCheckbox.addEventListener('change', () => {
        // Only affect visible rows
        const visibleCheckboxes = Array.from(studentCheckboxes).filter(cb => cb.closest('tr').style.display !== 'none');
        visibleCheckboxes.forEach(cb => cb.checked = selectAllCheckbox.checked);
        updateBulkActions();
    });

    studentCheckboxes.forEach(cb => {
        cb.addEventListener('change', updateBulkActions);
    });

    bulkDeleteButton.addEventListener('click', async () => {
        // Get IDs of checked and visible checkboxes
        const selectedIds = Array.from(studentCheckboxes)
            .filter(cb => cb.checked && cb.closest('tr').style.display !== 'none')
            .map(cb => cb.value);
            
        if (selectedIds.length === 0) {
            showToast('No visible students selected for deletion.', 'error');
            return;
        }
        
        // TODO: Replace with a custom modal confirmation
        if (!confirm(`Are you sure you want to delete ${selectedIds.length} student${selectedIds.length !== 1 ? 's' : ''}? This cannot be undone.`)) return;
        
        const originalButtonHTML = bulkDeleteButton.innerHTML;
        setLoadingState(bulkDeleteButton, true, originalButtonHTML);
        
        try {
            const result = await fetchWithErrorHandling('/delete_students_bulk', {
                method: 'POST',
                body: JSON.stringify({ student_ids: selectedIds })
            });
            
            if (result.success) {
                showToast(result.message || 'Students deleted successfully!', 'success');
                setTimeout(() => window.location.reload(), 1500); // Reload
            } else {
                throw new Error(result.message || 'Failed to delete students.');
            }
        } catch (error) {
            showToast(`Error: ${error.message}`, 'error');
            setLoadingState(bulkDeleteButton, false, originalButtonHTML);
        }
    });

    // Make update function global so filters can call it
    window.updateBulkActionsVisibility = updateBulkActions;
    updateBulkActions(); // Initial check
}

// --- Delete Functions ---
async function deleteStudent(studentId) {
    closeEditStudentModal(); // Close modal if open
    
    // TODO: Replace with a custom modal confirmation
    if (confirm(`Are you absolutely sure you want to delete this student? This cannot be undone and will remove all associated grades.`)) {
        try {
            const result = await fetchWithErrorHandling(`/delete_student/${studentId}`, {
                method: 'POST'
            });
            
            if (result.success) {
                showToast(result.message || 'Student deleted!', 'success');
                // If on students page, remove row
                const row = document.querySelector(`tr[data-student-id="${studentId}"]`);
                if (row) {
                    row.remove();
                } else {
                    // If on profile page, redirect
                    setTimeout(() => window.location.href = '/students', 1000);
                }
            } else {
                throw new Error(result.message || 'Failed to delete student.');
            }
        } catch (error) {
            console.error('Error deleting student:', error);
            showToast(`Error: ${error.message}`, 'error');
        }
    }
}

function deleteAssignment(assignmentId) {
    closeDropdowns(); // Close dropdown menu
    
    // TODO: Replace with a custom modal confirmation
    if (confirm(`Are you sure you want to delete this assignment? This action cannot be undone.`)) {
        fetchWithErrorHandling('/delete_assignment', {
            method: 'POST',
            body: JSON.stringify({ assignment_id: assignmentId })
        })
        .then(result => {
            if (result.success) {
                showToast('Assignment deleted.', 'success');
                const cardToRemove = document.querySelector(`button[onclick*="toggleDropdown('${assignmentId}')"]`)?.closest('.assignment-card');
                if (cardToRemove) {
                    cardToRemove.remove(); // Remove card from DOM
                    // Check if grid is now empty
                    const grid = document.querySelector('.assignments-grid');
                    if (grid && grid.querySelectorAll('.assignment-card').length === 0) {
                        // Show empty state
                         const emptyState = grid.querySelector('div:not(.assignment-card)');
                         if(emptyState) emptyState.style.display = '';
                    }
                } else {
                    location.reload(); // Fallback reload
                }
            } else {
                throw new Error(result.message || 'Failed to delete.');
            }
        })
        .catch(error => {
            console.error('Error deleting assignment:', error);
            showToast(`Error: ${error.message}`, 'error');
        });
    }
}

// --- Reset Data ---
async function resetAllData() {
    const resetButton = document.getElementById('confirmReset');
    const originalText = resetButton ? resetButton.innerHTML : 'Yes, Reset';
    
    if (resetButton) setLoadingState(resetButton, true, originalText);
    
    try {
        const result = await fetchWithErrorHandling('/reset_data', { method: 'POST' });
        if (result.success) {
            showToast('All data has been reset successfully!', 'success');
            hideResetConfirmation();
            setTimeout(() => window.location.href = '/', 1000);
        } else {
            throw new Error(result.message || 'Reset failed on server.');
        }
    } catch (error) {
        console.error('Error resetting data:', error);
        showToast(`Error: ${error.message}`, 'error');
        if (resetButton) setLoadingState(resetButton, false, originalText);
    }
}

// --- Dropdown Functions ---
function toggleDropdown(assignmentId) {
    const dropdown = document.getElementById(`dropdown-${assignmentId}`);
    if (dropdown) {
        const isHidden = dropdown.classList.contains('hidden');
        closeDropdowns(); // Close all others first
        if (isHidden) {
            dropdown.classList.remove('hidden');
        }
        // If it was already open, closeDropdowns() handled it
    }
}

function closeDropdowns(excludeId = null) {
    document.querySelectorAll('[id^="dropdown-"]').forEach(d => {
        if (!excludeId || d.id !== `dropdown-${excludeId}`) {
            d.classList.add('hidden');
        }
    });
}

function initializeDropdownListeners() {
    // Close dropdowns on click outside
    document.addEventListener('click', function(event) {
        const clickedToggle = event.target.closest('[onclick*="toggleDropdown"]');
        const clickedDropdown = event.target.closest('[id^="dropdown-"]');
        if (!clickedToggle && !clickedDropdown) {
            closeDropdowns();
        }
    });
    
    // Refresh section filter on class filter change (students.html)
    const classFilter = document.getElementById('classFilterStudents');
    const sectionFilter = document.getElementById('sectionFilter');
    
    if (classFilter && sectionFilter) {
        classFilter.addEventListener('change', async () => {
            // We are refreshing a <select> element here
            await refreshSelectWithOptions(sectionFilter, '/api/get_sections', 'Error loading sections');
            // After refreshing, re-apply the filters
            if (typeof initializeStudentPageFilters === 'function') {
                 // This assumes filterStudents() is accessible or re-run
                 // A bit complex, might be better to just trigger the filter function
                 const studentTableBody = document.getElementById('studentTableBody');
                 if(studentTableBody) {
                    const filterFunc = window.filterStudentsGlobally; // Need to expose filterStudents
                    if(filterFunc) filterFunc();
                 }
            }
        });
    }
}


// --- Assignment/Class Helpers ---
function selectAllClasses() {
    document.querySelectorAll('.assignment-class-checkbox').forEach(checkbox => {
        checkbox.checked = true;
    });
    const classSelectionError = document.getElementById('classSelectionError');
    if (classSelectionError) classSelectionError.classList.add('hidden');
}

function deselectAllClasses() {
    document.querySelectorAll('.assignment-class-checkbox').forEach(checkbox => {
        checkbox.checked = false;
    });
}

// --- Validation ---
// Checks for duplicate UID/Roll Number *before* submitting edit form
async function validateUniqueFields(studentId, uid, rollNumber) {
    try {
        const response = await fetchWithErrorHandling('/check_student_duplicates', {
            method: 'POST',
            body: JSON.stringify({
                student_id: studentId,
                uid: uid,
                roll_number: rollNumber
            })
        });
        
        if (response.success) {
            return response; // { success: true, has_duplicates: bool, duplicate_uid: "Name"|null, duplicate_roll: "Name"|null }
        } else {
            throw new Error(response.message || 'Duplicate check failed');
        }
    } catch (error) {
        console.error("Duplicate check failed:", error);
        // Return a "failure" state that indicates an error occurred
        return { success: false, has_duplicates: true, message: error.message };
    }
}

// --- Global Exports ---
// Make functions accessible from inline HTML event handlers
window.updateGrade = updateGrade;
window.updateAssignmentGrade = updateAssignmentGrade;
window.showToast = showToast;
window.viewStudentDetails = viewStudentDetails;
window.closeModal = closeModal;
window.showResetConfirmation = showResetConfirmation;
window.hideResetConfirmation = hideResetConfirmation;
window.resetAllData = resetAllData;
window.showAddStudentModal = showAddStudentModal;
window.closeAddStudentModal = closeAddStudentModal;
window.showEditStudentModal = showEditStudentModal;
window.closeEditStudentModal = closeEditStudentModal;
window.deleteStudent = deleteStudent;
window.toggleDropdown = toggleDropdown;
window.closeDropdowns = closeDropdowns;
window.editAssignment = (assignmentId) => {
    closeDropdowns();
    showNotImplementedToast(`Edit Assignment ${assignmentId}`);
};
window.deleteAssignment = deleteAssignment;
window.viewAssignmentGrades = (assignId, classId) => {
    closeDropdowns();
    if (classId) {
        // Redirect to the gradebook page, pre-selecting assignment and class
        window.location.href = `/gradebook?assignment_id=${assignId}&class_id=${classId}`;
    } else {
        showToast('Cannot determine class for assignment.', 'error');
    }
};
window.showNotImplementedToast = showNotImplementedToast;
window.showImportStudentsModal = showImportStudentsModal;
window.closeImportStudentsModal = closeImportStudentsModal;
window.showManageClassesModal = showManageClassesModal;
window.closeManageClassesModal = closeManageClassesModal;
window.showAddClassModal = showAddClassModal;
window.showEditClassModal = showEditClassModal;
window.closeClassFormModal = closeClassFormModal;
window.addClass = addClass;
window.editClass = editClass;
window.deleteClass = deleteClass;
window.selectAllClasses = selectAllClasses;
window.deselectAllClasses = deselectAllClasses;
window.validateUniqueFields = validateUniqueFields;
window.showAddAssignmentModal = showAddAssignmentModal;
window.closeAddAssignmentModal = closeAddAssignmentModal;

